"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const isConstructor=e=>e instanceof Function&&e.prototype&&e.prototype.constructor===e,isSymbol=e=>"symbol"==typeof e,DESIGN_TYPE="design:type",DESIGN_PARAMETER_TYPES="design:paramtypes",TOKEN="ioc:token",PARAMETERS="ioc:parameters",PROPERTIES="ioc:properties";var metadataKeys=Object.freeze({DESIGN_TYPE:DESIGN_TYPE,DESIGN_PARAMETER_TYPES:"design:paramtypes",TOKEN:TOKEN,PARAMETERS:PARAMETERS,PROPERTIES:PROPERTIES});const getTokenAnnotation=e=>Reflect.getOwnMetadata(TOKEN,e),setTokenAnnotation=(e,t)=>{Reflect.defineMetadata(TOKEN,t,e)},getParameterAnnotation=(e,t)=>(ensureParameterAnnotations(e),Reflect.getOwnMetadata(PARAMETERS,e)[t]),getParameterAnnotations=e=>(ensureParameterAnnotations(e),Reflect.getOwnMetadata(PARAMETERS,e)),ensureParameterAnnotations=e=>{if(!Reflect.hasOwnMetadata(PARAMETERS,e)){const t=(Reflect.getOwnMetadata("design:paramtypes",e)||[]).map(e=>createParameterAnnotation(e));Reflect.defineMetadata(PARAMETERS,t,e)}},getPropertyAnnotation=(e,t)=>(ensurePropertyAnnotation(e,t),Reflect.getOwnMetadata(PROPERTIES,e)[t]),getPropertyAnnotations=e=>(ensurePropertyAnnotations(e),Reflect.getOwnMetadata(PROPERTIES,e)),ensurePropertyAnnotations=e=>{Reflect.hasOwnMetadata(PROPERTIES,e)||Reflect.defineMetadata(PROPERTIES,{},e)},ensurePropertyAnnotation=(e,t)=>{const o=getPropertyAnnotations(e);if(!o.hasOwnProperty(t)){const n=Reflect.getOwnMetadata(DESIGN_TYPE,e.prototype,t);o[t]=createPropertyAnnotation(n)}},createParameterAnnotation=(e,t=!1)=>({token:e,optional:t}),createPropertyAnnotation=(e,t=!1)=>({token:e,optional:t});class InjectToken{constructor(e){isConstructor(e)?(this.value=Symbol.for(e.name),this.description=e.name):isSymbol(e)?(this.value=e,this.description=e.toString()):(this.value=Symbol.for(e),this.description=e)}}const CLASS_NOT_INJECTABLE=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be injected.`),inject=e=>(t,o,n)=>{const r="number"==typeof n,a=e instanceof InjectToken?e:e instanceof Function?getTokenAnnotation(e):r?getParameterAnnotation(t,n).token:getPropertyAnnotation(t.constructor,o).token;if(!a)throw CLASS_NOT_INJECTABLE(e);if(r){getParameterAnnotation(t,n).token=a}else{getPropertyAnnotation(t.constructor,o).token=a}},injectable=()=>e=>{const t=new InjectToken(e);setTokenAnnotation(e,t)},optional=()=>(e,t,o)=>{if("number"==typeof o){getParameterAnnotation(e,o).optional=!0}else{getPropertyAnnotation(e.constructor,t).optional=!0}},createClassFactory=e=>(...t)=>Reflect.construct(e,t),createSingletonFactory=e=>{let t;return(...o)=>(t||(t=Reflect.construct(e,o)),t)},createValueFactory=e=>()=>e,PROVIDER_UNREGISTERED=new Error("Provider is not registered with an injector.");class BaseProvider{constructor(e,t=[],o={}){this.factory=e,this.dependencies=t,this.properties=o}provide(e){if(e||(e=this.injector),!e)throw PROVIDER_UNREGISTERED;const t=this.resolveDependencies(e),o=this.resolveProperties(e);return this.createValue(t,o)}resolveDependencies(e){return this.dependencies.map(t=>e.resolve(t.token,t.optional))}resolveProperties(e){return Object.entries(this.properties).reduce((t,[o,n])=>(t[o]=e.resolve(n.token,n.optional),t),{})}createValue(e=[],t={}){const o=this.factory(...e);return o instanceof Object?Object.assign(o,t):o}}class ClassProvider extends BaseProvider{constructor(e,t,o){super(createClassFactory(e),t||getParameterAnnotations(e),o||getPropertyAnnotations(e))}}class SingletonProvider extends ClassProvider{provide(){return this._instance||(this._instance=super.provide()),this._instance}}class ValueProvider extends BaseProvider{constructor(e){super(createValueFactory(e))}}const CLASS_NOT_PROVIDABLE=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be resolved.`),NO_PROVIDER=e=>new Error(`No provider has been found for the requested token '${e.description}'.`);class Injector{constructor(e){this._registry=new Map,this._parent=null,e&&(this._parent=e)}provide(e,t){const o=e instanceof InjectToken?e:getTokenAnnotation(e);if(!o)throw CLASS_NOT_PROVIDABLE(e);t.injector=this,this._registry.set(o,t)}resolve(e,t=!1){let o;return o=e instanceof InjectToken?this._resolveToken(e,t):this._resolveConstructor(e,t)}_resolveConstructor(e,t=!1){const o=getTokenAnnotation(e);if(o)return this._getProvider(o)||this.provide(o,new ClassProvider(e)),this._resolveToken(o,t);if(!t)throw CLASS_NOT_PROVIDABLE(e)}_resolveToken(e,t=!1){const o=this._getProvider(e);if(o)return o.provide(this);if(!t)throw NO_PROVIDER(e)}_getProvider(e){return this._registry.has(e)?this._registry.get(e):this._parent?this._parent._getProvider(e):void 0}}exports.isSymbol=isSymbol,exports.isConstructor=isConstructor,exports.ANNOTATION=metadataKeys,exports.getTokenAnnotation=getTokenAnnotation,exports.setTokenAnnotation=setTokenAnnotation,exports.getParameterAnnotation=getParameterAnnotation,exports.getParameterAnnotations=getParameterAnnotations,exports.ensureParameterAnnotations=ensureParameterAnnotations,exports.getPropertyAnnotation=getPropertyAnnotation,exports.getPropertyAnnotations=getPropertyAnnotations,exports.ensurePropertyAnnotations=ensurePropertyAnnotations,exports.ensurePropertyAnnotation=ensurePropertyAnnotation,exports.createParameterAnnotation=createParameterAnnotation,exports.createPropertyAnnotation=createPropertyAnnotation,exports.CLASS_NOT_INJECTABLE=CLASS_NOT_INJECTABLE,exports.inject=inject,exports.injectable=injectable,exports.optional=optional,exports.createClassFactory=createClassFactory,exports.createSingletonFactory=createSingletonFactory,exports.createValueFactory=createValueFactory,exports.PROVIDER_UNREGISTERED=PROVIDER_UNREGISTERED,exports.BaseProvider=BaseProvider,exports.ClassProvider=ClassProvider,exports.SingletonProvider=SingletonProvider,exports.ValueProvider=ValueProvider,exports.InjectToken=InjectToken,exports.CLASS_NOT_PROVIDABLE=CLASS_NOT_PROVIDABLE,exports.NO_PROVIDER=NO_PROVIDER,exports.Injector=Injector;
//# sourceMappingURL=index.cjs.js.map
