"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const isConstructor=e=>e instanceof Function&&e.prototype&&e.prototype.constructor===e,isSymbol=e=>"symbol"==typeof e,DESIGN_TYPE="design:type",DESIGN_PARAMETER_TYPES="design:paramtypes",TOKEN="ioc:token",PARAMETERS="ioc:parameters",PROPERTIES="ioc:properties",getTokenAnnotation=e=>Reflect.getOwnMetadata(TOKEN,e),setTokenAnnotation=(e,t)=>{Reflect.defineMetadata(TOKEN,t,e)},getParameterAnnotation=(e,t)=>(ensureParameterAnnotations(e),Reflect.getOwnMetadata(PARAMETERS,e).get(t)),setParameterAnnotation=(e,t,o)=>{ensureParameterAnnotations(e);const n=Reflect.getOwnMetadata(PARAMETERS,e);Object.assign(n.get(t),o)},getParameterAnnotations=e=>(ensureParameterAnnotations(e),Reflect.getOwnMetadata(PARAMETERS,e)),getPropertyAnnotation=(e,t)=>(ensurePropertyAnnotation(e,t),Reflect.getOwnMetadata(PROPERTIES,e).get(t)),setPropertyAnnotation=(e,t,o)=>{ensurePropertyAnnotation(e,t);const n=Reflect.getOwnMetadata(PROPERTIES,e);Object.assign(n.get(t),o)},getPropertyAnnotations=e=>(ensurePropertyAnnotations(e),Reflect.getOwnMetadata(PROPERTIES,e)),ensureParameterAnnotations=e=>{if(!Reflect.hasOwnMetadata(PARAMETERS,e)){const t=Reflect.getOwnMetadata("design:paramtypes",e)||[],o=new Map(t.map((e,t)=>[t,createDependencyAnnotation(e)]));Reflect.defineMetadata(PARAMETERS,o,e)}},ensurePropertyAnnotation=(e,t)=>{const o=getPropertyAnnotations(e);if(!o.has(t)){const n=Reflect.getOwnMetadata(DESIGN_TYPE,e.prototype,t);o.set(t,createDependencyAnnotation(n))}},ensurePropertyAnnotations=e=>{Reflect.hasOwnMetadata(PROPERTIES,e)||Reflect.defineMetadata(PROPERTIES,new Map,e)},createDependencyAnnotation=(e,t=!1)=>({token:e,optional:t});class InjectToken{constructor(e){this.description=e}}const inject=e=>(t,o,n)=>{const r="number"==typeof n,a=e instanceof InjectToken?e:r?getParameterAnnotation(t,n).token:getPropertyAnnotation(t.constructor,o).token;r?setParameterAnnotation(t,n,{token:a}):setPropertyAnnotation(t.constructor,o,{token:a})},injectable=()=>e=>{const t=new InjectToken(e.name);setTokenAnnotation(e,t)},optional=()=>(e,t,o)=>{"number"==typeof o?setParameterAnnotation(e,o,{optional:!0}):setPropertyAnnotation(e.constructor,t,{optional:!0})},createClassFactory=e=>(...t)=>Reflect.construct(e,t),createSingletonFactory=e=>{let t;return(...o)=>(t||(t=Reflect.construct(e,o)),t)},createValueFactory=e=>()=>e,PROVIDER_UNREGISTERED=new Error("Provider is not registered with an injector.");class BaseProvider{constructor(e,t=new Map,o=new Map){this.factory=e,this.parameters=t,this.properties=o}provide(e){if(e||(e=this.injector),!e)throw PROVIDER_UNREGISTERED;const t=this.resolveParameters(e),o=this.resolveProperties(e);return this.createValue(t,o)}resolveParameters(e){const t=[];return this.parameters.forEach(({token:o,optional:n},r)=>t[r]=e.resolve(o,n)),t}resolveProperties(e){const t={};return this.properties.forEach(({token:o,optional:n},r)=>t[r]=e.resolve(o,n)),t}createValue(e=[],t={}){const o=this.factory(...e);return o instanceof Object?Object.assign(o,t):o}}class ClassProvider extends BaseProvider{constructor(e,t,o){super(createClassFactory(e),t||getParameterAnnotations(e),o||getPropertyAnnotations(e))}}class SingletonProvider extends ClassProvider{provide(e){return this._instance||(this._instance=super.provide(e)),this._instance}}class ValueProvider extends BaseProvider{constructor(e){super(createValueFactory(e))}}function __decorate(e,t,o,n){var r,a=arguments.length,s=a<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,o):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,o,n);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(s=(a<3?r(s):a>3?r(t,o,s):r(t,o))||s);return a>3&&s&&Object.defineProperty(t,o,s),s}function __metadata(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}var Injector_1;const CLASS_NOT_PROVIDABLE=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be provided.`),CLASS_NOT_RESOLVABLE=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be resolved.`),NO_PROVIDER=e=>new Error(`No provider has been found for the requested token '${e.description}'.`);exports.Injector=Injector_1=class{constructor(e){this._registry=new Map,this._parent=null,e&&(this._parent=e),this.register(Injector_1,new ValueProvider(this))}register(e,t){const o=e instanceof InjectToken?e:getTokenAnnotation(e);if(!o)throw CLASS_NOT_PROVIDABLE(e);t.injector=this,this._registry.set(o,t)}resolve(e,t=!1){let o;return o=e instanceof InjectToken?this._resolveToken(e,t):this._resolveConstructor(e,t)}_resolveConstructor(e,t=!1){const o=getTokenAnnotation(e);if(o)return this._getProvider(o)||this.register(o,new ClassProvider(e)),this._resolveToken(o,t);if(!t)throw CLASS_NOT_RESOLVABLE(e)}_resolveToken(e,t=!1){const o=this._getProvider(e);if(o)return o.provide(this);if(!t)throw NO_PROVIDER(e)}_getProvider(e){return this._registry.has(e)?this._registry.get(e):this._parent?this._parent._getProvider(e):void 0}},exports.Injector=Injector_1=__decorate([injectable(),__metadata("design:paramtypes",[exports.Injector])],exports.Injector),exports.isSymbol=isSymbol,exports.isConstructor=isConstructor,exports.getTokenAnnotation=getTokenAnnotation,exports.setTokenAnnotation=setTokenAnnotation,exports.getParameterAnnotation=getParameterAnnotation,exports.setParameterAnnotation=setParameterAnnotation,exports.getParameterAnnotations=getParameterAnnotations,exports.getPropertyAnnotation=getPropertyAnnotation,exports.setPropertyAnnotation=setPropertyAnnotation,exports.getPropertyAnnotations=getPropertyAnnotations,exports.inject=inject,exports.injectable=injectable,exports.optional=optional,exports.createClassFactory=createClassFactory,exports.createSingletonFactory=createSingletonFactory,exports.createValueFactory=createValueFactory,exports.PROVIDER_UNREGISTERED=PROVIDER_UNREGISTERED,exports.BaseProvider=BaseProvider,exports.ClassProvider=ClassProvider,exports.SingletonProvider=SingletonProvider,exports.ValueProvider=ValueProvider,exports.InjectToken=InjectToken,exports.CLASS_NOT_PROVIDABLE=CLASS_NOT_PROVIDABLE,exports.CLASS_NOT_RESOLVABLE=CLASS_NOT_RESOLVABLE,exports.NO_PROVIDER=NO_PROVIDER;
//# sourceMappingURL=index.cjs.js.map
