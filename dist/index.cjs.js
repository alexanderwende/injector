"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const isConstructor=e=>e instanceof Function&&e.prototype&&e.prototype.constructor===e,isSymbol=e=>"symbol"==typeof e,DESIGN_TYPE="design:type",DESIGN_PARAMETER_TYPES="design:paramtypes",TOKEN="ioc:token",PARAMETERS="ioc:parameters",PROPERTIES="ioc:properties",getTokenAnnotation=e=>Reflect.getOwnMetadata(TOKEN,e),setTokenAnnotation=(e,t)=>{Reflect.defineMetadata(TOKEN,t,e)},getParameterAnnotation=(e,t)=>(ensureParameterAnnotations(e),Reflect.getOwnMetadata(PARAMETERS,e).get(t)),setParameterAnnotation=(e,t,n)=>{ensureParameterAnnotations(e);const o=Reflect.getOwnMetadata(PARAMETERS,e);Object.assign(o.get(t),n)},getParameterAnnotations=e=>(ensureParameterAnnotations(e),Reflect.getOwnMetadata(PARAMETERS,e)),getPropertyAnnotation=(e,t)=>(ensurePropertyAnnotation(e,t),Reflect.getOwnMetadata(PROPERTIES,e).get(t)),setPropertyAnnotation=(e,t,n)=>{ensurePropertyAnnotation(e,t);const o=Reflect.getOwnMetadata(PROPERTIES,e);Object.assign(o.get(t),n)},getPropertyAnnotations=e=>(ensurePropertyAnnotations(e),Reflect.getOwnMetadata(PROPERTIES,e)),ensureParameterAnnotations=e=>{if(!Reflect.hasOwnMetadata(PARAMETERS,e)){const t=Reflect.getOwnMetadata("design:paramtypes",e)||[],n=new Map(t.map((e,t)=>[t,createDependencyAnnotation(e)]));Reflect.defineMetadata(PARAMETERS,n,e)}},ensurePropertyAnnotation=(e,t)=>{const n=getPropertyAnnotations(e);if(!n.has(t)){const o=Reflect.getOwnMetadata(DESIGN_TYPE,e.prototype,t);n.set(t,createDependencyAnnotation(o))}},ensurePropertyAnnotations=e=>{Reflect.hasOwnMetadata(PROPERTIES,e)||Reflect.defineMetadata(PROPERTIES,new Map,e)},createDependencyAnnotation=(e,t=!1)=>({token:e,optional:t});class InjectToken{constructor(e){this.description=e}}const inject=e=>(t,n,o)=>{const r="number"==typeof o,s=e instanceof InjectToken?e:r?getParameterAnnotation(t,o).token:getPropertyAnnotation(t.constructor,n).token;r?setParameterAnnotation(t,o,{token:s}):setPropertyAnnotation(t.constructor,n,{token:s})},injectable=()=>e=>{const t=new InjectToken(e.name);setTokenAnnotation(e,t)},optional=()=>(e,t,n)=>{"number"==typeof n?setParameterAnnotation(e,n,{optional:!0}):setPropertyAnnotation(e.constructor,t,{optional:!0})},createClassFactory=e=>(...t)=>Reflect.construct(e,t),createSingletonFactory=e=>{let t;return(...n)=>(t||(t=Reflect.construct(e,n)),t)},createValueFactory=e=>()=>e,PROVIDER_UNREGISTERED=new Error("Provider is not registered with an injector.");class BaseProvider{constructor(e,t=new Map,n=new Map){this.factory=e,this.dependencies=t,this.properties=n}provide(e){if(e||(e=this.injector),!e)throw PROVIDER_UNREGISTERED;const t=this.resolveDependencies(e),n=this.resolveProperties(e);return this.createValue(t,n)}resolveDependencies(e){const t=[];return this.dependencies.forEach(({token:n,optional:o},r)=>t[r]=e.resolve(n,o)),t}resolveProperties(e){const t={};return this.properties.forEach(({token:n,optional:o},r)=>t[r]=e.resolve(n,o)),t}createValue(e=[],t={}){const n=this.factory(...e);return n instanceof Object?Object.assign(n,t):n}}class ClassProvider extends BaseProvider{constructor(e,t,n){super(createClassFactory(e),t||getParameterAnnotations(e),n||getPropertyAnnotations(e))}}class SingletonProvider extends ClassProvider{provide(){return this._instance||(this._instance=super.provide()),this._instance}}class ValueProvider extends BaseProvider{constructor(e){super(createValueFactory(e))}}const CLASS_NOT_PROVIDABLE=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be resolved.`),NO_PROVIDER=e=>new Error(`No provider has been found for the requested token '${e.description}'.`);class Injector{constructor(e){this._registry=new Map,this._parent=null,e&&(this._parent=e)}provide(e,t){const n=e instanceof InjectToken?e:getTokenAnnotation(e);if(!n)throw CLASS_NOT_PROVIDABLE(e);t.injector=this,this._registry.set(n,t)}resolve(e,t=!1){let n;return n=e instanceof InjectToken?this._resolveToken(e,t):this._resolveConstructor(e,t)}_resolveConstructor(e,t=!1){const n=getTokenAnnotation(e);if(n)return this._getProvider(n)||this.provide(n,new ClassProvider(e)),this._resolveToken(n,t);if(!t)throw CLASS_NOT_PROVIDABLE(e)}_resolveToken(e,t=!1){const n=this._getProvider(e);if(n)return n.provide(this);if(!t)throw NO_PROVIDER(e)}_getProvider(e){return this._registry.has(e)?this._registry.get(e):this._parent?this._parent._getProvider(e):void 0}}exports.isSymbol=isSymbol,exports.isConstructor=isConstructor,exports.getTokenAnnotation=getTokenAnnotation,exports.setTokenAnnotation=setTokenAnnotation,exports.getParameterAnnotation=getParameterAnnotation,exports.setParameterAnnotation=setParameterAnnotation,exports.getParameterAnnotations=getParameterAnnotations,exports.getPropertyAnnotation=getPropertyAnnotation,exports.setPropertyAnnotation=setPropertyAnnotation,exports.getPropertyAnnotations=getPropertyAnnotations,exports.inject=inject,exports.injectable=injectable,exports.optional=optional,exports.createClassFactory=createClassFactory,exports.createSingletonFactory=createSingletonFactory,exports.createValueFactory=createValueFactory,exports.PROVIDER_UNREGISTERED=PROVIDER_UNREGISTERED,exports.BaseProvider=BaseProvider,exports.ClassProvider=ClassProvider,exports.SingletonProvider=SingletonProvider,exports.ValueProvider=ValueProvider,exports.InjectToken=InjectToken,exports.CLASS_NOT_PROVIDABLE=CLASS_NOT_PROVIDABLE,exports.NO_PROVIDER=NO_PROVIDER,exports.Injector=Injector;
//# sourceMappingURL=index.cjs.js.map
