const e=e=>e instanceof Function&&e.prototype&&e.prototype.constructor===e,t=e=>"symbol"==typeof e,o="ioc:parameters",n="ioc:properties";var r=Object.freeze({DESIGN_TYPE:"design:type",DESIGN_PARAMETER_TYPES:"design:paramtypes",TOKEN:"ioc:token",PARAMETERS:o,PROPERTIES:n});const s=e=>Reflect.getOwnMetadata("ioc:token",e),i=(e,t)=>{Reflect.defineMetadata("ioc:token",t,e)},a=(e,t)=>(d(e),Reflect.getOwnMetadata(o,e)[t]),c=e=>(d(e),Reflect.getOwnMetadata(o,e)),d=e=>{if(!Reflect.hasOwnMetadata(o,e)){const t=(Reflect.getOwnMetadata("design:paramtypes",e)||[]).map(e=>u(e));Reflect.defineMetadata(o,t,e)}},l=(e,t)=>(f(e,t),Reflect.getOwnMetadata(n,e)[t]),p=e=>(h(e),Reflect.getOwnMetadata(n,e)),h=e=>{Reflect.hasOwnMetadata(n,e)||Reflect.defineMetadata(n,{},e)},f=(e,t)=>{const o=p(e);if(!o.hasOwnProperty(t)){const n=Reflect.getOwnMetadata("design:type",e.prototype,t);o[t]=v(n)}},u=(e,t=!1)=>({token:e,optional:t}),v=(e,t=!1)=>({token:e,optional:t});class g{constructor(o){e(o)?(this.value=Symbol.for(o.name),this.description=o.name):t(o)?(this.value=o,this.description=o.toString()):(this.value=Symbol.for(o),this.description=o)}}const w=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be injected.`),_=e=>(t,o,n)=>{const r="number"==typeof n,i=e instanceof g?e:e instanceof Function?s(e):r?a(t,n).token:l(t.constructor,o).token;if(!i)throw w(e);if(r){a(t,n).token=i}else{l(t.constructor,o).token=i}},y=()=>e=>{const t=new g(e);i(e,t)},R=()=>(e,t,o)=>{if("number"==typeof o){a(e,o).optional=!0}else{l(e.constructor,t).optional=!0}},O=e=>(...t)=>Reflect.construct(e,t),b=e=>{let t;return(...o)=>(t||(t=Reflect.construct(e,o)),t)},k=e=>()=>e,E=new Error("Provider is not registered with an injector.");class M{constructor(e,t=[],o={}){this.factory=e,this.dependencies=t,this.properties=o}provide(e){if(e||(e=this.injector),!e)throw E;const t=this.resolveDependencies(e),o=this.resolveProperties(e);return this.createValue(t,o)}resolveDependencies(e){return this.dependencies.map(t=>e.resolve(t.token,t.optional))}resolveProperties(e){return Object.entries(this.properties).reduce((t,[o,n])=>(t[o]=e.resolve(n.token,n.optional),t),{})}createValue(e=[],t={}){const o=this.factory(...e);return o instanceof Object?Object.assign(o,t):o}}class m extends M{constructor(e,t,o){super(O(e),t||c(e),o||p(e))}}class P extends m{provide(){return this._instance||(this._instance=super.provide()),this._instance}}class T extends M{constructor(e){super(k(e))}}const j=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be resolved.`),S=e=>new Error(`No provider has been found for the requested token '${e.description}'.`);class N{constructor(e){this._registry=new Map,this._parent=null,e&&(this._parent=e)}provide(e,t){const o=e instanceof g?e:s(e);if(!o)throw j(e);t.injector=this,this._registry.set(o,t)}resolve(e,t=!1){let o;return o=e instanceof g?this._resolveToken(e,t):this._resolveConstructor(e,t)}_resolveConstructor(e,t=!1){const o=s(e);if(!o)throw j(e);return this._getProvider(o)||this.provide(o,new m(e)),this._resolveToken(o,t)}_resolveToken(e,t=!1){const o=this._getProvider(e);if(o)return o.provide(this);if(!t)throw S(e)}_getProvider(e){return this._registry.has(e)?this._registry.get(e):this._parent?this._parent._getProvider(e):void 0}}export{t as isSymbol,e as isConstructor,r as ANNOTATION,s as getTokenAnnotation,i as setTokenAnnotation,a as getParameterAnnotation,c as getParameterAnnotations,d as ensureParameterAnnotations,l as getPropertyAnnotation,p as getPropertyAnnotations,h as ensurePropertyAnnotations,f as ensurePropertyAnnotation,u as createParameterAnnotation,v as createPropertyAnnotation,w as CLASS_NOT_INJECTABLE,_ as inject,y as injectable,R as optional,O as createClassFactory,b as createSingletonFactory,k as createValueFactory,E as PROVIDER_UNREGISTERED,M as BaseProvider,m as ClassProvider,P as SingletonProvider,T as ValueProvider,g as InjectToken,j as CLASS_NOT_PROVIDABLE,S as NO_PROVIDER,N as Injector};
//# sourceMappingURL=index.esm.js.map
