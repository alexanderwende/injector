const e=e=>e instanceof Function&&e.prototype&&e.prototype.constructor===e,t=e=>"symbol"==typeof e,r="ioc:parameters",o="ioc:properties",n=e=>Reflect.getOwnMetadata("ioc:token",e),s=(e,t)=>{Reflect.defineMetadata("ioc:token",t,e)},a=(e,t)=>(d(e),Reflect.getOwnMetadata(r,e).get(t)),c=(e,t,o)=>{d(e);const n=Reflect.getOwnMetadata(r,e);Object.assign(n.get(t),o)},i=e=>(d(e),Reflect.getOwnMetadata(r,e)),l=(e,t)=>(h(e,t),Reflect.getOwnMetadata(o,e).get(t)),f=(e,t,r)=>{h(e,t);const n=Reflect.getOwnMetadata(o,e);Object.assign(n.get(t),r)},p=e=>(u(e),Reflect.getOwnMetadata(o,e)),d=e=>{if(!Reflect.hasOwnMetadata(r,e)){const t=Reflect.getOwnMetadata("design:paramtypes",e)||[],o=new Map(t.map((e,t)=>[t,g(e)]));Reflect.defineMetadata(r,o,e)}},h=(e,t)=>{const r=p(e);if(!r.has(t)){const o=Reflect.getOwnMetadata("design:type",e.prototype,t);r.set(t,g(o))}},u=e=>{Reflect.hasOwnMetadata(o,e)||Reflect.defineMetadata(o,new Map,e)},g=(e,t=!1)=>({token:e,optional:t});class w{constructor(e){this.description=e}}const v=e=>(t,r,o)=>{const n="number"==typeof o,s=e instanceof w?e:n?a(t,o).token:l(t.constructor,r).token;n?c(t,o,{token:s}):f(t.constructor,r,{token:s})},y=()=>e=>{const t=new w(e.name);s(e,t)},R=()=>(e,t,r)=>{"number"==typeof r?c(e,r,{optional:!0}):f(e.constructor,t,{optional:!0})},_=e=>(...t)=>Reflect.construct(e,t),M=e=>{let t;return(...r)=>(t||(t=Reflect.construct(e,r)),t)},b=e=>()=>e,O=new Error("Provider is not registered with an injector.");class m{constructor(e,t=new Map,r=new Map){this.factory=e,this.parameters=t,this.properties=r}provide(e){if(e||(e=this.injector),!e)throw O;const t=this.resolveParameters(e),r=this.resolveProperties(e);return this.createValue(t,r)}resolveParameters(e){const t=[];return this.parameters.forEach(({token:r,optional:o},n)=>t[n]=e.resolve(r,o)),t}resolveProperties(e){const t={};return this.properties.forEach(({token:r,optional:o},n)=>t[n]=e.resolve(r,o)),t}createValue(e=[],t={}){const r=this.factory(...e);return r instanceof Object?Object.assign(r,t):r}}class j extends m{constructor(e,t,r){super(_(e),t||i(e),r||p(e))}}class k extends j{provide(e){return this._instance||(this._instance=super.provide(e)),this._instance}}class P extends m{constructor(e){super(b(e))}}var E;const x=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be provided.`),C=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be resolved.`),T=e=>new Error(`No provider has been found for the requested token '${e.description}'.`);let $=E=class{constructor(e){this._registry=new Map,this._parent=null,e&&(this._parent=e),this.register(E,new P(this))}register(e,t){const r=e instanceof w?e:n(e);if(!r)throw x(e);t.injector=this,this._registry.set(r,t)}resolve(e,t=!1){let r;return r=e instanceof w?this._resolveToken(e,t):this._resolveConstructor(e,t)}_resolveConstructor(e,t=!1){const r=n(e);if(r)return this._getProvider(r)||this.register(r,new j(e)),this._resolveToken(r,t);if(!t)throw C(e)}_resolveToken(e,t=!1){const r=this._getProvider(e);if(r)return r.provide(this);if(!t)throw T(e)}_getProvider(e){return this._registry.has(e)?this._registry.get(e):this._parent?this._parent._getProvider(e):void 0}};$=E=function(e,t,r,o){var n,s=arguments.length,a=s<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,r,o);else for(var c=e.length-1;c>=0;c--)(n=e[c])&&(a=(s<3?n(a):s>3?n(t,r,a):n(t,r))||a);return s>3&&a&&Object.defineProperty(t,r,a),a}([y(),function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}("design:paramtypes",[$])],$);export{t as isSymbol,e as isConstructor,n as getTokenAnnotation,s as setTokenAnnotation,a as getParameterAnnotation,c as setParameterAnnotation,i as getParameterAnnotations,l as getPropertyAnnotation,f as setPropertyAnnotation,p as getPropertyAnnotations,v as inject,y as injectable,R as optional,_ as createClassFactory,M as createSingletonFactory,b as createValueFactory,O as PROVIDER_UNREGISTERED,m as BaseProvider,j as ClassProvider,k as SingletonProvider,P as ValueProvider,w as InjectToken,x as CLASS_NOT_PROVIDABLE,C as CLASS_NOT_RESOLVABLE,T as NO_PROVIDER,$ as Injector};
//# sourceMappingURL=index.esm.js.map
