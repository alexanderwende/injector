const e=e=>e instanceof Function&&e.prototype&&e.prototype.constructor===e,t=e=>"symbol"==typeof e,n="ioc:parameters",o="ioc:properties",s=e=>Reflect.getOwnMetadata("ioc:token",e),r=(e,t)=>{Reflect.defineMetadata("ioc:token",t,e)},a=(e,t)=>(h(e),Reflect.getOwnMetadata(n,e).get(t)),i=(e,t,o)=>{h(e);const s=Reflect.getOwnMetadata(n,e);Object.assign(s.get(t),o)},c=e=>(h(e),Reflect.getOwnMetadata(n,e)),p=(e,t)=>(f(e,t),Reflect.getOwnMetadata(o,e).get(t)),d=(e,t,n)=>{f(e,t);const s=Reflect.getOwnMetadata(o,e);Object.assign(s.get(t),n)},l=e=>(u(e),Reflect.getOwnMetadata(o,e)),h=e=>{if(!Reflect.hasOwnMetadata(n,e)){const t=Reflect.getOwnMetadata("design:paramtypes",e)||[],o=new Map(t.map((e,t)=>[t,g(e)]));Reflect.defineMetadata(n,o,e)}},f=(e,t)=>{const n=l(e);if(!n.has(t)){const o=Reflect.getOwnMetadata("design:type",e.prototype,t);n.set(t,g(o))}},u=e=>{Reflect.hasOwnMetadata(o,e)||Reflect.defineMetadata(o,new Map,e)},g=(e,t=!1)=>({token:e,optional:t});class v{constructor(e){this.description=e}}const w=e=>(t,n,o)=>{const s="number"==typeof o,r=e instanceof v?e:s?a(t,o).token:p(t.constructor,n).token;s?i(t,o,{token:r}):d(t.constructor,n,{token:r})},_=()=>e=>{const t=new v(e.name);r(e,t)},M=()=>(e,t,n)=>{"number"==typeof n?i(e,n,{optional:!0}):d(e.constructor,t,{optional:!0})},R=e=>(...t)=>Reflect.construct(e,t),y=e=>{let t;return(...n)=>(t||(t=Reflect.construct(e,n)),t)},O=e=>()=>e,k=new Error("Provider is not registered with an injector.");class b{constructor(e,t=new Map,n=new Map){this.factory=e,this.dependencies=t,this.properties=n}provide(e){if(e||(e=this.injector),!e)throw k;const t=this.resolveDependencies(e),n=this.resolveProperties(e);return this.createValue(t,n)}resolveDependencies(e){const t=[];return this.dependencies.forEach(({token:n,optional:o},s)=>t[s]=e.resolve(n,o)),t}resolveProperties(e){const t={};return this.properties.forEach(({token:n,optional:o},s)=>t[s]=e.resolve(n,o)),t}createValue(e=[],t={}){const n=this.factory(...e);return n instanceof Object?Object.assign(n,t):n}}class j extends b{constructor(e,t,n){super(R(e),t||c(e),n||l(e))}}class m extends j{provide(){return this._instance||(this._instance=super.provide()),this._instance}}class P extends b{constructor(e){super(O(e))}}const E=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be resolved.`),x=e=>new Error(`No provider has been found for the requested token '${e.description}'.`);class C{constructor(e){this._registry=new Map,this._parent=null,e&&(this._parent=e)}provide(e,t){const n=e instanceof v?e:s(e);if(!n)throw E(e);t.injector=this,this._registry.set(n,t)}resolve(e,t=!1){let n;return n=e instanceof v?this._resolveToken(e,t):this._resolveConstructor(e,t)}_resolveConstructor(e,t=!1){const n=s(e);if(n)return this._getProvider(n)||this.provide(n,new j(e)),this._resolveToken(n,t);if(!t)throw E(e)}_resolveToken(e,t=!1){const n=this._getProvider(e);if(n)return n.provide(this);if(!t)throw x(e)}_getProvider(e){return this._registry.has(e)?this._registry.get(e):this._parent?this._parent._getProvider(e):void 0}}export{t as isSymbol,e as isConstructor,s as getTokenAnnotation,r as setTokenAnnotation,a as getParameterAnnotation,i as setParameterAnnotation,c as getParameterAnnotations,p as getPropertyAnnotation,d as setPropertyAnnotation,l as getPropertyAnnotations,w as inject,_ as injectable,M as optional,R as createClassFactory,y as createSingletonFactory,O as createValueFactory,k as PROVIDER_UNREGISTERED,b as BaseProvider,j as ClassProvider,m as SingletonProvider,P as ValueProvider,v as InjectToken,E as CLASS_NOT_PROVIDABLE,x as NO_PROVIDER,C as Injector};
//# sourceMappingURL=index.esm.js.map
