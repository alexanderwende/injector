import"@abraham/reflection";const e=e=>e instanceof Function&&e.prototype&&e.prototype.constructor===e,t=e=>"symbol"==typeof e,o="ioc:parameters",r="ioc:properties";var n=Object.freeze({DESIGN_TYPE:"design:type",DESIGN_PARAMETER_TYPES:"design:paramtypes",TOKEN:"ioc:token",PARAMETERS:o,PROPERTIES:r});const s=e=>Reflect.getOwnMetadata("ioc:token",e),i=(e,t)=>{Reflect.defineMetadata("ioc:token",t,e)},a=(e,t)=>(l(e),Reflect.getOwnMetadata(o,e)[t]),c=e=>(l(e),Reflect.getOwnMetadata(o,e)),l=e=>{if(!Reflect.hasOwnMetadata(o,e)){const t=(Reflect.getOwnMetadata("design:paramtypes",e)||[]).map(e=>u(e));Reflect.defineMetadata(o,t,e)}},p=(e,t)=>(f(e,t),Reflect.getOwnMetadata(r,e)[t]),d=e=>(h(e),Reflect.getOwnMetadata(r,e)),h=e=>{Reflect.hasOwnMetadata(r,e)||Reflect.defineMetadata(r,{},e)},f=(e,t)=>{const o=d(e);if(!o.hasOwnProperty(t)){const r=Reflect.getOwnMetadata("design:type",e.prototype,t);o[t]=v(r)}},u=(e,t=!1)=>({token:e,optional:t}),v=(e,t=!1)=>({token:e,optional:t});class g{constructor(o){e(o)?(this.value=Symbol.for(o.name),this.description=o.name):t(o)?(this.value=o,this.description=o.toString()):(this.value=Symbol.for(o),this.description=o)}}const w=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be injected.`),_=e=>(t,o,r)=>{const n="number"==typeof r,i=e instanceof g?e:e instanceof Function?s(e):n?a(t,r).token:p(t.constructor,o).token;if(!i)throw w(e);if(n){a(t,r).token=i}else{p(t.constructor,o).token=i}},y=()=>e=>{const t=new g(e);i(e,t)},R=()=>(e,t,o)=>{if("number"==typeof o){a(e,o).optional=!0}else{p(e.constructor,t).optional=!0}},O=e=>(...t)=>Reflect.construct(e,t),b=e=>{let t;return(...o)=>(t||(t=Reflect.construct(e,o)),t)},m=e=>()=>e,k=new Error("Provider is not registered with an injector.");class E{constructor(e,t=[],o={}){this.factory=e,this.dependencies=t,this.properties=o}provide(e){if(e||(e=this.injector),!e)throw k;const t=this.resolveDependencies(e),o=this.resolveProperties(e);return this.createValue(t,o)}resolveDependencies(e){return this.dependencies.map(t=>e.resolve(t.token,t.optional))}resolveProperties(e){return Object.entries(this.properties).reduce((t,[o,r])=>(t[o]=e.resolve(r.token,r.optional),t),{})}createValue(e=[],t={}){const o=this.factory(...e);return o instanceof Object?Object.assign(o,t):o}}class M extends E{constructor(e,t,o){super(O(e),t||c(e),o||d(e))}}class P extends M{provide(){return this._instance||(this._instance=super.provide()),this._instance}}class T extends E{constructor(e){super(m(e))}}const j=e=>new Error(`Class '${e.name}' has not been decorated as injectable and cannot be resolved.`),S=e=>new Error(`No provider has been found for the requested token '${e.description}'.`);class N{constructor(e){this._registry=new Map,this._parent=null,e&&(this._parent=e)}provide(e,t){const o=e instanceof g?e:s(e);if(!o)throw j(e);t.injector=this,this._registry.set(o,t)}resolve(e,t=!1){let o;return o=e instanceof g?this._resolveToken(e,t):this._resolveConstructor(e,t)}_resolveConstructor(e,t=!1){const o=s(e);if(!o)throw j(e);return this._getProvider(o)||this.provide(o,new M(e)),this._resolveToken(o,t)}_resolveToken(e,t=!1){const o=this._getProvider(e);if(o)return o.provide(this);if(!t)throw S(e)}_getProvider(e){return this._registry.has(e)?this._registry.get(e):this._parent?this._parent._getProvider(e):void 0}}export{t as isSymbol,e as isConstructor,n as ANNOTATION,s as getTokenAnnotation,i as setTokenAnnotation,a as getParameterAnnotation,c as getParameterAnnotations,l as ensureParameterAnnotations,p as getPropertyAnnotation,d as getPropertyAnnotations,h as ensurePropertyAnnotations,f as ensurePropertyAnnotation,u as createParameterAnnotation,v as createPropertyAnnotation,w as CLASS_NOT_INJECTABLE,_ as inject,y as injectable,R as optional,O as createClassFactory,b as createSingletonFactory,m as createValueFactory,k as PROVIDER_UNREGISTERED,E as BaseProvider,M as ClassProvider,P as SingletonProvider,T as ValueProvider,g as InjectToken,j as CLASS_NOT_PROVIDABLE,S as NO_PROVIDER,N as Injector};
//# sourceMappingURL=index.esm.js.map
