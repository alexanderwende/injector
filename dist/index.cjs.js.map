{"version":3,"file":"index.cjs.js","sources":["../src/utils/index.ts","../src/annotations/metadata-keys.ts","../src/annotations/index.ts","../src/inject-token.ts","../src/decorators/inject.ts","../src/decorators/injectable.ts","../src/decorators/optional.ts","../src/factories/class-factory.ts","../src/factories/singleton-factory.ts","../src/factories/value-factory.ts","../src/providers/base-provider.ts","../src/providers/class-provider.ts","../src/providers/singleton-provider.ts","../src/providers/value-provider.ts","../src/injector.ts"],"sourcesContent":["export type Constructor<T = any> = { new (...args: any[]): T; }\n\nexport const isConstructor = (constructorFn: any): constructorFn is Constructor => {\n\n    return constructorFn instanceof Function && constructorFn.prototype && constructorFn.prototype.constructor === constructorFn;\n};\n\nexport const isSymbol = (symbol: any): symbol is Symbol => {\n\n    return typeof symbol === 'symbol';\n};\n","export const DESIGN_TYPE            = 'design:type';\nexport const DESIGN_PARAMETER_TYPES = 'design:paramtypes';\n\nexport const TOKEN           = 'ioc:token';\nexport const PARAMETERS      = 'ioc:parameters';\nexport const PROPERTIES      = 'ioc:properties';","import { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\nimport * as ANNOTATION from './metadata-keys';\n\nexport { ANNOTATION };\n\nexport interface ParameterAnnotation<T = any> {\n    token: InjectToken<T> | Constructor<T>;\n    optional: boolean;\n}\n\nexport interface PropertyAnnotation<T = any> {\n    token: InjectToken<T> | Constructor<T>;\n    optional: boolean;\n}\n\nexport const getTokenAnnotation = <T> (target: Constructor<T>): InjectToken<T> => {\n\n    return Reflect.getOwnMetadata(ANNOTATION.TOKEN, target);\n};\n\nexport const setTokenAnnotation = <T> (target: Constructor<T>, token: InjectToken<T>): void => {\n\n    Reflect.defineMetadata(ANNOTATION.TOKEN, token, target);\n};\n\nexport const getParameterAnnotation = (target: Constructor, parameterIndex: number): ParameterAnnotation => {\n\n    ensureParameterAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target)[parameterIndex];\n};\n\nexport const getParameterAnnotations = (target: Constructor): ParameterAnnotation[] => {\n\n    ensureParameterAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target);\n};\n\nexport const ensureParameterAnnotations = (target: Constructor) => {\n\n    if (!Reflect.hasOwnMetadata(ANNOTATION.PARAMETERS, target)) {\n\n        const parameterTypes: Constructor[]               = Reflect.getOwnMetadata(ANNOTATION.DESIGN_PARAMETER_TYPES, target) || [];\n        const parameterAnnotations: ParameterAnnotation[] = parameterTypes.map(type => createParameterAnnotation(type));\n\n        Reflect.defineMetadata(ANNOTATION.PARAMETERS, parameterAnnotations, target);\n    }\n};\n\nexport const getPropertyAnnotation = (target: Constructor, propertyKey: string): PropertyAnnotation => {\n\n    ensurePropertyAnnotation(target, propertyKey);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target)[propertyKey];\n};\n\nexport const getPropertyAnnotations = (target: Constructor): { [key: string]: PropertyAnnotation } => {\n\n    ensurePropertyAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target);\n};\n\nexport const ensurePropertyAnnotations = (target: Constructor) => {\n\n    if (!Reflect.hasOwnMetadata(ANNOTATION.PROPERTIES, target)) {\n\n        Reflect.defineMetadata(ANNOTATION.PROPERTIES, {}, target);\n    }\n};\n\nexport const ensurePropertyAnnotation = (target: Constructor, propertyKey: string) => {\n\n    ensurePropertyAnnotations(target);\n\n    const properties: { [key: string]: PropertyAnnotation } = Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target);\n\n    if (!properties.hasOwnProperty(propertyKey)) {\n\n        properties[propertyKey] = createPropertyAnnotation(Reflect.getOwnMetadata(ANNOTATION.DESIGN_TYPE, target.prototype, propertyKey));\n    }\n};\n\nexport const createParameterAnnotation = <T> (token: InjectToken<T> | Constructor<T>, optional = false): ParameterAnnotation<T> => ({\n    token:    token,\n    optional: optional\n});\n\nexport const createPropertyAnnotation = <T> (token: InjectToken<T> | Constructor<T>, optional = false): PropertyAnnotation<T> => ({\n    token:    token,\n    optional: optional\n});","import { Constructor, isConstructor, isSymbol } from './utils';\n\nexport class InjectToken<T = any> {\n\n    description: string;\n\n    value: Symbol;\n\n    constructor (value: Constructor<T> | symbol | string) {\n\n        if (isConstructor(value)) {\n\n            this.value       = Symbol.for(value.name);\n            this.description = value.name;\n\n        } else if (isSymbol(value)) {\n\n            this.value       = value;\n            this.description = value.toString();\n\n        } else {\n\n            this.value       = Symbol.for(value);\n            this.description = value;\n        }\n    }\n}","import { getParameterAnnotation, getPropertyAnnotation, getTokenAnnotation } from '../annotations';\nimport { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\n\nexport const inject = <T> (constructorOrToken?: Constructor<T> | InjectToken<T>) => {\n\n    return (target: Object, propertyKey: string | symbol, parameterIndex?: number): void => {\n\n        const isParameterDecorator = typeof parameterIndex === 'number';\n\n        const token: Constructor<T> | InjectToken<T> = (constructorOrToken instanceof InjectToken) ?\n                                                       constructorOrToken :\n                                                       (constructorOrToken instanceof Function) ?\n                                                       getTokenAnnotation(constructorOrToken) :\n                                                       (isParameterDecorator) ?\n                                                       getParameterAnnotation(target as Constructor, parameterIndex!).token :\n                                                       getPropertyAnnotation(target.constructor as Constructor, propertyKey as string).token;\n\n        if (isParameterDecorator) {\n\n            // decorator is a parameter decorator\n            const parameterAnnotation = getParameterAnnotation(target as Constructor, parameterIndex!);\n\n            parameterAnnotation.token = token;\n\n            // console.log('inject()... ', parameterAnnotation);\n\n        } else {\n\n            // decorator is a property decorator\n            const propertyAnnotation = getPropertyAnnotation(target.constructor as Constructor, propertyKey as string);\n\n            propertyAnnotation.token = token;\n\n            // console.log('inject()... ', propertyAnnotation);\n        }\n    };\n};\n","import { setTokenAnnotation } from '../annotations';\nimport { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\n\nexport const injectable = () => {\n\n    return (target: Constructor<object>) => {\n\n        const token = new InjectToken(target);\n\n        setTokenAnnotation(target, token);\n    };\n};\n","import { getParameterAnnotation, getPropertyAnnotation } from '../annotations';\nimport { Constructor } from '../utils';\n\nexport const optional = () => {\n\n    return (target: Object, propertyKey: string | symbol, parameterIndex?: number): void => {\n\n        if (typeof parameterIndex === 'number') {\n\n            // decorator is a parameter decorator\n            const parameterAnnotation = getParameterAnnotation(target as Constructor<any>, parameterIndex);\n\n            parameterAnnotation.optional = true;\n\n        } else {\n\n            // decorator is a property decorator\n            const propertyAnnotation = getPropertyAnnotation(target.constructor as Constructor<any>, propertyKey as string);\n\n            propertyAnnotation.optional = true;\n        }\n    };\n};\n","import { Constructor } from '../utils';\nimport { Factory } from './factory';\n\nexport interface ClassFactory<T> extends Factory<T> {\n    (...dependencies: any[]): T;\n}\n\nexport const createClassFactory = <T> (constructorFn: Constructor<T>): ClassFactory<T> => {\n\n    return (...dependencies: any[]) => {\n\n        return Reflect.construct(constructorFn, dependencies);\n    };\n};\n","import { Constructor } from '../utils';\nimport { Factory } from './factory';\n\nexport interface SingletonFactory<T> extends Factory<T> {\n    (...dependencies: any[]): T;\n}\n\nexport const createSingletonFactory = <T> (constructorFn: Constructor<T>): SingletonFactory<T> => {\n\n    let instance: T;\n\n    return (...dependencies: any[]) => {\n\n        if (!instance) instance = Reflect.construct(constructorFn, dependencies);\n\n        return instance;\n    };\n};\n","import { Factory } from './factory';\n\nexport interface ValueFactory<T> extends Factory<T> {\n    (): T;\n}\n\nexport const createValueFactory = <T> (value: T): ValueFactory<T> => {\n\n    return () => value;\n};\n","import { ParameterAnnotation, PropertyAnnotation } from '../annotations';\nimport { Factory } from '../factories';\nimport { Injector } from '../injector';\nimport { Provider } from './provider';\n\nexport const PROVIDER_UNREGISTERED = new Error('Provider is not registered with an injector.');\n\nexport class BaseProvider<T> implements Provider<T> {\n\n    public injector: Injector | undefined;\n\n    constructor (public factory: Factory<T>,\n                 public dependencies: ParameterAnnotation[]               = [],\n                 public properties: { [key: string]: PropertyAnnotation } = {}) {}\n\n    provide (injector?: Injector): T {\n\n        if (!injector) injector = this.injector;\n\n        if (!injector) throw PROVIDER_UNREGISTERED;\n\n        // console.group('Provider.provide()');\n\n        // console.log('provider: ', this);\n        // console.log('resolving dependencies: ', this.dependencies);\n\n        const dependencies = this.resolveDependencies(injector);\n\n        // console.log('resolved dependencies: ', dependencies);\n\n        // console.log('resolving properties: ', this.properties);\n\n        const properties = this.resolveProperties(injector);\n\n        // console.log('resolved properties: ', properties);\n\n        // console.groupEnd();\n\n        return this.createValue(dependencies, properties);\n    }\n\n    resolveDependencies (injector: Injector): any[] {\n\n        return this.dependencies.map(dependency => injector.resolve(dependency.token, dependency.optional));\n    }\n\n    resolveProperties (injector: Injector): { [key: string]: any } {\n\n        return Object.entries(this.properties).reduce((result, [key, value]) => {\n\n            result[key] = injector.resolve(value.token, value.optional);\n\n            return result;\n\n        }, {} as { [key: string]: any });\n    }\n\n    createValue (dependencies: any[] = [], properties: { [key: string]: any } = {}): T {\n\n        const value = this.factory(...dependencies);\n\n        return (value instanceof Object) ? Object.assign(value, properties) : value;\n    }\n}\n","import { getParameterAnnotations, getPropertyAnnotations, ParameterAnnotation, PropertyAnnotation } from '../annotations';\nimport { createClassFactory } from '../factories';\nimport { Constructor } from '../utils';\nimport { BaseProvider } from './base-provider';\n\nexport class ClassProvider<T> extends BaseProvider<T> {\n\n    constructor (constructorFn: Constructor<T>,\n                 dependencies?: ParameterAnnotation[],\n                 properties?: { [key: string]: PropertyAnnotation }) {\n\n        super(\n            createClassFactory(constructorFn),\n            dependencies || getParameterAnnotations(constructorFn),\n            properties || getPropertyAnnotations(constructorFn)\n        );\n    }\n}\n","import { ClassProvider } from './class-provider';\n\nexport class SingletonProvider<T> extends ClassProvider<T> {\n\n    protected _instance: T | undefined;\n\n    provide (): T {\n\n        if (!this._instance) this._instance = super.provide();\n\n        return this._instance;\n    }\n}\n","import { createValueFactory } from '../factories';\nimport { BaseProvider } from './base-provider';\n\nexport class ValueProvider<T> extends BaseProvider<T> {\n\n    constructor (value: any) {\n\n        super(createValueFactory(value));\n    }\n}\n","import { getTokenAnnotation } from './annotations';\nimport { InjectToken } from './inject-token';\nimport { ClassProvider, Provider } from './providers';\nimport { Constructor } from './utils';\n\nexport const CLASS_NOT_INJECTABLE = (constructorFn: Constructor) => new Error(`Class '${constructorFn.name}' has not been decorated as injectable and cannot be resolved.`);\nexport const NO_PROVIDER          = (token: InjectToken) => new Error(`No provider has been found for the requested token '${token.description}'.`);\n\nexport class Injector {\n\n    private _registry: Map<InjectToken<any>, Provider<any>> = new Map();\n\n    private _parent: Injector | null = null;\n\n    constructor (parent?: Injector) {\n\n        if (parent) this._parent = parent;\n    }\n\n    provide<T> (constructorOrToken: Constructor<T> | InjectToken<T>, provider: Provider<T>) {\n\n        const token: InjectToken<T> = constructorOrToken instanceof InjectToken ?\n                                      constructorOrToken :\n                                      getTokenAnnotation(constructorOrToken);\n\n        // class was not decorated with @injectable, throw\n        if (!token) throw CLASS_NOT_INJECTABLE(constructorOrToken as Constructor);\n\n        provider.injector = this;\n\n        this._registry.set(token, provider);\n    }\n\n    resolve<T> (target: Constructor<T> | InjectToken<T>, optional = false): T | undefined {\n\n        let resolved: T | undefined;\n\n        // console.group('Injector.resolve()');\n\n        if (target instanceof InjectToken) {\n\n            // console.log('resolving: ', target.value);\n            resolved = this._resolveToken(target, optional);\n\n        } else {\n\n            // console.log('resolving: ', target.name);\n            resolved = this._resolveConstructor(target, optional);\n        }\n\n        // console.groupEnd();\n\n        return resolved;\n    }\n\n    protected _resolveConstructor<T> (constructorFn: Constructor<T>, optional = false): T | undefined {\n\n        const token: InjectToken<T> = getTokenAnnotation(constructorFn);\n\n        // class was not decorated with @injectable, throw\n        if (!token) throw CLASS_NOT_INJECTABLE(constructorFn);\n\n        // class has no provider yet, we create one\n        if (!this._getProvider(token)) {\n\n            this.provide(token, new ClassProvider(constructorFn));\n        }\n\n        return this._resolveToken(token, optional);\n    }\n\n    protected _resolveToken<T> (token: InjectToken<T>, optional = false): T | undefined {\n\n        const provider = this._getProvider(token);\n\n        if (!provider) {\n\n            if (!optional) throw NO_PROVIDER(token);\n\n            return undefined;\n        }\n\n        return provider!.provide(this);\n    }\n\n    protected _getProvider<T> (token: InjectToken<T>): Provider<T> | undefined {\n\n        if (this._registry.has(token)) {\n\n            return this._registry.get(token);\n\n        } else if (this._parent) {\n\n            return this._parent._getProvider(token);\n        }\n    }\n}\n"],"names":["ANNOTATION.TOKEN","ANNOTATION.PARAMETERS","ANNOTATION.DESIGN_PARAMETER_TYPES","ANNOTATION.PROPERTIES","ANNOTATION.DESIGN_TYPE"],"mappings":"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"}