{"version":3,"file":"index.cjs.js","sources":["../src/utils/index.ts","../src/annotations/metadata-keys.ts","../src/annotations/annotations.ts","../src/inject-token.ts","../src/decorators/inject.ts","../src/decorators/injectable.ts","../src/decorators/optional.ts","../src/factories/class-factory.ts","../src/factories/singleton-factory.ts","../src/factories/value-factory.ts","../src/providers/base-provider.ts","../src/providers/class-provider.ts","../src/providers/singleton-provider.ts","../src/providers/value-provider.ts","../src/injector.ts"],"sourcesContent":["export type Constructor<T = any> = { new (...args: any[]): T; }\n\nexport const isConstructor = (constructorFn: any): constructorFn is Constructor => {\n\n    return constructorFn instanceof Function && constructorFn.prototype && constructorFn.prototype.constructor === constructorFn;\n};\n\nexport const isSymbol = (symbol: any): symbol is Symbol => {\n\n    return typeof symbol === 'symbol';\n};\n","/**\n * @internal\n */\nexport const DESIGN_TYPE = 'design:type';\n\n/**\n * @internal\n */\nexport const DESIGN_PARAMETER_TYPES = 'design:paramtypes';\n\n/**\n * @internal\n */\nexport const TOKEN = 'ioc:token';\n\n/**\n * @internal\n */\nexport const PARAMETERS = 'ioc:parameters';\n\n/**\n * @internal\n */\nexport const PROPERTIES = 'ioc:properties';\n","import { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\nimport * as ANNOTATION from './metadata-keys';\n\n/**\n * A dependency annotation describes a constructor parameter or class property dependency\n */\nexport interface DependencyAnnotation<T = any> {\n    token: InjectToken<T> | Constructor<T>;\n    optional: boolean;\n}\n\n/**\n * A map of constructor parameter dependency annotations\n */\nexport type ParameterAnnotations = Map<number, DependencyAnnotation>;\n\n/**\n * A map of class property dependency annotations\n */\nexport type PropertyAnnotations = Map<PropertyKey, DependencyAnnotation>;\n\n/**\n * Gets the {@link InjectToken} of a class\n *\n * @internal\n */\nexport const getTokenAnnotation = <T> (target: Constructor<T>): InjectToken<T> | undefined => {\n\n    return Reflect.getOwnMetadata(ANNOTATION.TOKEN, target);\n};\n\n/**\n * Sets the {@link InjectToken} of a class\n *\n * @internal\n */\nexport const setTokenAnnotation = <T> (target: Constructor<T>, token: InjectToken<T>): void => {\n\n    Reflect.defineMetadata(ANNOTATION.TOKEN, token, target);\n};\n\n/**\n * Gets the {@link DependencyAnnotation} of a constructor parameter\n *\n * @internal\n */\nexport const getParameterAnnotation = (target: Constructor, parameterIndex: number): DependencyAnnotation => {\n\n    ensureParameterAnnotations(target);\n\n    return (Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target) as ParameterAnnotations).get(parameterIndex)!;\n};\n\n/**\n * Updates a {@link DependencyAnnotation} of a constructor parameter with the values from the partial annotation\n *\n * @internal\n */\nexport const setParameterAnnotation = (\n    target: Constructor,\n    parameterIndex: number,\n    annotation: Partial<DependencyAnnotation>): void => {\n\n    ensureParameterAnnotations(target);\n\n    const annotations = Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target) as ParameterAnnotations;\n\n    Object.assign(annotations.get(parameterIndex), annotation);\n};\n\n/**\n * Gets the {@link ParameterAnnotations} of a class's constructor\n *\n * @internal\n */\nexport const getParameterAnnotations = (target: Constructor): ParameterAnnotations => {\n\n    ensureParameterAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target) as ParameterAnnotations;\n};\n\n/**\n * Gets the {@link DependencyAnnotation} of a class property\n *\n * @internal\n */\nexport const getPropertyAnnotation = (target: Constructor, propertyKey: PropertyKey): DependencyAnnotation => {\n\n    ensurePropertyAnnotation(target, propertyKey);\n\n    // we have to use a type cast as TypeScript currently doesn't support Symbols as index types\n    return (Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target) as PropertyAnnotations).get(propertyKey)!;\n};\n\n/**\n * Updates a {@link DependencyAnnotation} of a class property with the values from the partial annotation\n *\n * @internal\n */\nexport const setPropertyAnnotation = (\n    target: Constructor,\n    propertyKey: PropertyKey,\n    annotation: Partial<DependencyAnnotation>): void => {\n\n    ensurePropertyAnnotation(target, propertyKey);\n\n    const annotations = Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target) as PropertyAnnotations;\n\n    Object.assign(annotations.get(propertyKey), annotation);\n};\n\n/**\n * Gets the {@link PropertyAnnotations} of a class\n *\n * @internal\n */\nexport const getPropertyAnnotations = (target: Constructor): PropertyAnnotations => {\n\n    ensurePropertyAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target) as PropertyAnnotations;\n};\n\n\n\nconst ensureParameterAnnotations = (target: Constructor) => {\n\n    if (!Reflect.hasOwnMetadata(ANNOTATION.PARAMETERS, target)) {\n\n        const parameterTypes: Constructor[] = Reflect.getOwnMetadata(ANNOTATION.DESIGN_PARAMETER_TYPES, target) || [];\n        const parameterAnnotations: ParameterAnnotations = new Map(\n            parameterTypes.map(\n                (type, index) => [index, createDependencyAnnotation(type)] as [number, DependencyAnnotation]\n            ));\n\n        Reflect.defineMetadata(ANNOTATION.PARAMETERS, parameterAnnotations, target);\n    }\n};\n\nconst ensurePropertyAnnotation = (target: Constructor, propertyKey: PropertyKey) => {\n\n    const properties = getPropertyAnnotations(target);\n\n    if (!properties.has(propertyKey)) {\n\n        const propertyType = Reflect.getOwnMetadata(\n            ANNOTATION.DESIGN_TYPE,\n            target.prototype,\n            // we force a type cast here as reflection types the PropertyKey as string | symbol,\n            // at runtime numeric property keys work too\n            propertyKey as string | symbol\n        ) as InjectToken | Constructor;\n\n        properties.set(propertyKey, createDependencyAnnotation(propertyType));\n    }\n};\n\nconst ensurePropertyAnnotations = (target: Constructor) => {\n\n    if (!Reflect.hasOwnMetadata(ANNOTATION.PROPERTIES, target)) {\n\n        Reflect.defineMetadata(ANNOTATION.PROPERTIES, new Map(), target);\n    }\n};\n\nconst createDependencyAnnotation = <T> (\n    token: InjectToken<T> | Constructor<T>,\n    optional = false\n): DependencyAnnotation<T> => ({\n    token: token,\n    optional: optional\n});\n","/**\n * A token that represents a dependency\n *\n * @remarks\n * An {@link InjectToken} should be used to inject any type, which does not have a runtime\n * representation, e.g. an interface, callable type or a plain value. An {@link InjectToken}\n * is tied to a {@link Provider} using the {@link Injector.provide} method.\n *\n * ```typescript\n * interface MessageService {\n *      getMessage (): string;\n * }\n *\n * interface MessageClientConfig {\n *      checkMessages: boolean;\n *      answerMessages: boolean;\n * }\n *\n * class FooMessageService implements MessageService {\n *      getMessage () { return 'foo'; }\n * }\n *\n * // use a generic type to tie the token to the interface type\n * const MESSAGE_SERVICE = new InjectToken<MessageService>('MessageService');\n * const CONFIG = new InjectToken<MessageClientConfig>('MessageClientConfig');\n *\n * const injector = new Injector();\n *\n * injector.provide(MESSAGE_SERVICE, new ClassProvider(FooMessageService));\n * injector.provide(CONFIG, new ValueProvider({ checkMessages: true, answerMessages: false }));\n *\n * injector.resolve(MESSAGE_SERVICE).getMessage(); // --> 'foo'\n * injector.resolve(CONFIG); // --> { checkMessages: true, answerMessages: false }\n * ```\n */\nexport class InjectToken<T = any> {\n\n    constructor (public description: string) { }\n}\n","import { getParameterAnnotation, getPropertyAnnotation, setParameterAnnotation, setPropertyAnnotation } from '../annotations';\nimport { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\n\n/**\n * Decorates a class property or constructor parameter as injection target\n *\n * @remarks\n * The inject decorator has two use cases:\n * * Injecting dependencies into class properties\n * * Injecting non-class dependencies through {@link InjectToken}s\n *\n * When used to inject class properties, it can be used without specifying an {@link InjectToken}.\n * The property type will be used as token and the injector will create a {@link ClassProvider} for\n * the type automatically.\n *\n * ```typescript\n * // decorate the dependency as injectable\n * @injectable()\n * class MessageService {\n *     getMessage () { return 'foo'; }\n * }\n *\n * // decorate the consumer as injectable\n * @injectable()\n * class MessageClient {\n *     // decorate the property you want to inject\n *     @inject()\n *     public service!: MessageService;\n * }\n * ```\n *\n * When used to inject non-class properties, an {@link InjectToken} needs to be provided.\n * An {@link InjectToken} can be used for property and parameter injection alike.\n *\n * ```typescript\n * // an interface describing the MessageService\n * interface MessageService {\n *     getMessage (): string;\n * }\n *\n * // an `InjectToken` representing the interface\n * // use a generic type to tie the token to the interface type\n * const MESSAGE_SERVICE = new InjectToken<MessageService>('MessageService');\n *\n * // a class implementing the MessageService interface - decorated as injectable\n * @injectable()\n * class FooMessageService implements MessageService {\n *     getMessage () { return 'foo'; }\n * }\n *\n * // decorate the consumer as injectable\n * @injectable()\n * class MessageClient {\n *     // inject the implementation by using the `InjectToken`\n *     constructor (@inject(MESSAGE_SERVICE) public service: MessageService) {}\n * }\n *\n * // create an `Injector` instance\n * const injector = new Injector();\n *\n * // tell the injector how to provide the MESSAGE_SERVICE token\n * // we are using a `ClassProvider` here, but we could use other providers as well\n * injector.provide(MESSAGE_SERVICE, new ClassProvider(FooMessageService));\n * ```\n *\n * @param injectToken - An {@link InjectToken} identifying the dependency to inject\n */\nexport const inject = <T> (injectToken?: InjectToken<T>) => {\n\n    return (target: Object, propertyKey: PropertyKey, parameterIndex?: number): void => {\n\n        const isParameterDecorator = typeof parameterIndex === 'number';\n\n        const token: InjectToken<T> | Constructor<T> = injectToken instanceof InjectToken\n            ? injectToken\n            : isParameterDecorator\n                ? getParameterAnnotation(target as Constructor, parameterIndex!).token\n                : getPropertyAnnotation(target.constructor as Constructor, propertyKey).token;\n\n        // TODO: This sets the token twice - once during the get (caused by ensure) and then by the set\n        if (isParameterDecorator) {\n\n            setParameterAnnotation(target as Constructor, parameterIndex!, { token });\n\n        } else {\n\n            setPropertyAnnotation(target.constructor as Constructor, propertyKey, { token });\n        }\n    };\n};\n","import { setTokenAnnotation } from '../annotations';\nimport { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\n\nexport const injectable = () => {\n\n    return (target: Constructor<object>) => {\n\n        const token = new InjectToken(target.name);\n\n        setTokenAnnotation(target, token);\n    };\n};\n","import { setParameterAnnotation, setPropertyAnnotation } from '../annotations';\nimport { Constructor } from '../utils';\n\nexport const optional = () => {\n\n    return (target: Object, propertyKey: string | symbol, parameterIndex?: number): void => {\n\n        if (typeof parameterIndex === 'number') {\n\n            // decorator is a parameter decorator\n            setParameterAnnotation(target as Constructor, parameterIndex, { optional: true });\n\n        } else {\n\n            // decorator is a property decorator\n            setPropertyAnnotation(target.constructor as Constructor, propertyKey, { optional: true });\n        }\n    };\n};\n","import { Constructor } from '../utils';\nimport { Factory } from './factory';\n\nexport interface ClassFactory<T> extends Factory<T> {\n    (...dependencies: any[]): T;\n}\n\nexport const createClassFactory = <T> (constructorFn: Constructor<T>): ClassFactory<T> => {\n\n    return (...dependencies: any[]) => {\n\n        return Reflect.construct(constructorFn, dependencies);\n    };\n};\n","import { Constructor } from '../utils';\nimport { Factory } from './factory';\n\nexport interface SingletonFactory<T> extends Factory<T> {\n    (...dependencies: any[]): T;\n}\n\nexport const createSingletonFactory = <T> (constructorFn: Constructor<T>): SingletonFactory<T> => {\n\n    let instance: T;\n\n    return (...dependencies: any[]) => {\n\n        if (!instance) instance = Reflect.construct(constructorFn, dependencies);\n\n        return instance;\n    };\n};\n","import { Factory } from './factory';\n\nexport interface ValueFactory<T> extends Factory<T> {\n    (): T;\n}\n\nexport const createValueFactory = <T> (value: T): ValueFactory<T> => {\n\n    return () => value;\n};\n","import { ParameterAnnotations, PropertyAnnotations, DependencyAnnotation } from '../annotations';\nimport { Factory } from '../factories';\nimport { Injector } from '../injector';\nimport { Provider } from './provider';\n\n/**\n * @internal\n */\nexport const PROVIDER_UNREGISTERED = new Error('Provider is not registered with an injector.');\n\n/**\n * The `BaseProvider` class\n *\n * @remarks\n * `BaseProvider` uses a factory function to provide a value. The provider's parameter dependencies\n * will be used to invoke the factory function. The provider's property dependencies will be set on\n * the factory function's return value. Each of the dependencies will be resolved using an\n * `Injector` instance which must be passed to the provider's {@link provide} method.\n *\n * // TODO: test this\n * ```typescript\n * @injectable()\n * class Foo {}\n *\n * @injectable()\n * class Bar {}\n *\n * interface FooBar {\n *      foo: Foo;\n *      bar: Bar;\n * }\n *\n * const token = new InjectToken<FooBar>('FooBar');\n *\n * const factory = (foo: Foo, bar: Bar) => ({ foo: foo, bar: bar });\n *\n * const provider = new BaseProvider(factory, new Map([\n *      [0, { token: Foo, optional: false }],\n *      [1, { token: Bar, optional: false }],\n * ]));\n *\n * const injector = new Injector();\n *\n * provider.provide(injector);\n *\n * // or more naturally\n *\n * injector.provide(token, provider);\n *\n * injector.resolve(token);\n * ```\n */\nexport class BaseProvider<T> implements Provider<T> {\n\n    public injector: Injector | undefined;\n\n    /**\n     * The `BaseProvider` constructor\n     *\n     * @param factory - The provider's factory function\n     * @param dependencies - The parameter dependencies of the factory function\n     * @param properties - The property dependencies of the value returned from the factory function\n     */\n    constructor (\n        public factory: Factory<T>,\n        public dependencies: ParameterAnnotations = new Map(),\n        public properties: PropertyAnnotations = new Map()) { }\n\n    /**\n     * Get the provider's provided value\n     *\n     * @param injector - The injector to use to resolve the provider's dependencies\n     */\n    provide (injector?: Injector): T {\n\n        if (!injector) injector = this.injector;\n\n        if (!injector) throw PROVIDER_UNREGISTERED;\n\n        const dependencies = this.resolveDependencies(injector);\n\n        const properties = this.resolveProperties(injector);\n\n        return this.createValue(dependencies, properties);\n    }\n\n    /**\n     * Resolves the parameter dependencies for the factory from the current injector\n     *\n     * @param injector - The current injector that runs the provider\n     * @returns An array of resolved parameter dependencies\n     */\n    protected resolveDependencies (injector: Injector): any[] {\n\n        const parameters: any[] = [];\n\n        this.dependencies.forEach(({ token, optional }, index) => parameters[index] = injector.resolve(token, optional));\n\n        return parameters;\n    }\n\n    /**\n     * Resolves the property dependencies for the factory from the current injector\n     *\n     * @param injector - The current injector that runs the provider\n     * @returns An object of resolved property dependencies\n     */\n    protected resolveProperties (injector: Injector): any {\n\n        const result: any = {};\n\n        this.properties.forEach(({ token, optional }, key) => result[key] = injector.resolve(token, optional));\n\n        return result;\n    }\n\n    /**\n     * Creates the provider's provided value by invoking the factory\n     *\n     * @param dependencies - The parameter dependencies of the factory\n     * @param properties - The property dependencies of the instance returned from the factory\n     * @returns The value created by the provider's factory\n     */\n    protected createValue (dependencies: any[] = [], properties: any = {}): T {\n\n        const value = this.factory(...dependencies);\n\n        return (value instanceof Object) ? Object.assign(value, properties) : value;\n    }\n}\n","import {\n    getParameterAnnotations,\n    getPropertyAnnotations,\n    ParameterAnnotations,\n    PropertyAnnotations\n} from '../annotations';\nimport { createClassFactory } from '../factories';\nimport { Constructor } from '../utils';\nimport { BaseProvider } from './base-provider';\n\nexport class ClassProvider<T> extends BaseProvider<T> {\n\n    constructor (\n        constructorFn: Constructor<T>,\n        dependencies?: ParameterAnnotations,\n        properties?: PropertyAnnotations) {\n\n        super(\n            createClassFactory(constructorFn),\n            dependencies || getParameterAnnotations(constructorFn),\n            properties || getPropertyAnnotations(constructorFn)\n        );\n    }\n}\n","import { ClassProvider } from './class-provider';\n\nexport class SingletonProvider<T> extends ClassProvider<T> {\n\n    protected _instance: T | undefined;\n\n    provide (): T {\n\n        if (!this._instance) this._instance = super.provide();\n\n        return this._instance;\n    }\n}\n","import { createValueFactory } from '../factories';\nimport { BaseProvider } from './base-provider';\n\nexport class ValueProvider<T> extends BaseProvider<T> {\n\n    constructor (value: T) {\n\n        super(createValueFactory(value));\n    }\n}\n","import { getTokenAnnotation } from './annotations';\nimport { InjectToken } from './inject-token';\nimport { ClassProvider, Provider } from './providers';\nimport { Constructor } from './utils';\n\n/**\n * @internal\n */\nexport const CLASS_NOT_PROVIDABLE = (constructorFn: Constructor) => new Error(`Class '${ constructorFn.name }' has not been decorated as injectable and cannot be resolved.`);\n\n/**\n * @internal\n */\nexport const NO_PROVIDER = (token: InjectToken) => new Error(`No provider has been found for the requested token '${ token.description }'.`);\n\n/**\n * The injector class\n */\nexport class Injector {\n\n    private _registry: Map<InjectToken<any>, Provider<any>> = new Map();\n\n    private _parent: Injector | null = null;\n\n    /**\n     * Creates an injector instance.\n     *\n     * @remarks\n     * A child injector can be created by passing the parent injector as a constructor argument.\n     *\n     * ```typescript\n     * const rootInjector = new Injector();\n     * const childInjector = new Injector(rootInjector);\n     * ```\n     *\n     * @param parent - A parent injector\n     */\n    constructor (parent?: Injector) {\n\n        if (parent) this._parent = parent;\n\n        // TODO: add provider for injector instance itself\n    }\n\n    /**\n     * Provide a provider for a dependency to the injector\n     *\n     * @param constructorOrToken - A class constructor or {@link InjectToken} to provide\n     * @param provider - A {@link Provider} which will be used to resolve the class or token\n     */\n    provide<T> (constructorOrToken: Constructor<T> | InjectToken<T>, provider: Provider<T>) {\n\n        const token: InjectToken<T> | undefined = constructorOrToken instanceof InjectToken\n            ? constructorOrToken\n            : getTokenAnnotation(constructorOrToken);\n\n        // class was not decorated with @injectable, throw\n        if (!token) throw CLASS_NOT_PROVIDABLE(constructorOrToken as Constructor);\n\n        provider.injector = this;\n\n        this._registry.set(token, provider);\n    }\n\n    /**\n     * Resolve a dependency\n     *\n     * @param target - A class constructor or {@link InjectToken} to resolve\n     * @param optional - Should the dependency be optional. If `true` the injector will not throw an error if it cannot resolve the dependency and returns `undefined`. If `false` the injector will throw an error if the dependency cannot be resolved.\n     */\n    resolve<T> (target: Constructor<T> | InjectToken<T>, optional = false): T | undefined {\n\n        let resolved: T | undefined;\n\n        if (target instanceof InjectToken) {\n\n            resolved = this._resolveToken(target, optional);\n\n        } else {\n\n            resolved = this._resolveConstructor(target, optional);\n        }\n\n        return resolved;\n    }\n\n    /**\n     * @internal\n     */\n    protected _resolveConstructor<T> (constructorFn: Constructor<T>, optional = false): T | undefined {\n\n        const token: InjectToken<T> | undefined = getTokenAnnotation(constructorFn);\n\n        // class was not decorated with @injectable\n        if (!token) {\n\n            if(!optional) throw CLASS_NOT_PROVIDABLE(constructorFn);\n\n            return undefined;\n        }\n\n        // class has no provider yet, we create one\n        if (!this._getProvider(token)) {\n\n            this.provide(token, new ClassProvider(constructorFn));\n        }\n\n        return this._resolveToken(token, optional);\n    }\n\n    /**\n     * @internal\n     */\n    protected _resolveToken<T> (token: InjectToken<T>, optional = false): T | undefined {\n\n        const provider = this._getProvider(token);\n\n        if (!provider) {\n\n            if (!optional) throw NO_PROVIDER(token);\n\n            return undefined;\n        }\n\n        return provider!.provide(this);\n    }\n\n    /**\n     * @internal\n     */\n    protected _getProvider<T> (token: InjectToken<T>): Provider<T> | undefined {\n\n        if (this._registry.has(token)) {\n\n            return this._registry.get(token);\n\n        } else if (this._parent) {\n\n            return this._parent._getProvider(token);\n        }\n    }\n}\n"],"names":["isConstructor","constructorFn","Function","prototype","constructor","isSymbol","symbol","DESIGN_TYPE","DESIGN_PARAMETER_TYPES","TOKEN","PARAMETERS","PROPERTIES","getTokenAnnotation","target","Reflect","getOwnMetadata","ANNOTATION.TOKEN","setTokenAnnotation","token","defineMetadata","getParameterAnnotation","parameterIndex","ensureParameterAnnotations","ANNOTATION.PARAMETERS","get","setParameterAnnotation","annotation","annotations","Object","assign","getParameterAnnotations","getPropertyAnnotation","propertyKey","ensurePropertyAnnotation","ANNOTATION.PROPERTIES","setPropertyAnnotation","getPropertyAnnotations","ensurePropertyAnnotations","hasOwnMetadata","parameterTypes","parameterAnnotations","Map","map","type","index","createDependencyAnnotation","properties","has","propertyType","ANNOTATION.DESIGN_TYPE","set","optional","InjectToken","[object Object]","description","this","inject","injectToken","isParameterDecorator","injectable","name","createClassFactory","dependencies","construct","createSingletonFactory","instance","createValueFactory","value","PROVIDER_UNREGISTERED","Error","BaseProvider","factory","injector","resolveDependencies","resolveProperties","createValue","parameters","forEach","resolve","result","key","ClassProvider","super","SingletonProvider","_instance","provide","ValueProvider","CLASS_NOT_PROVIDABLE","NO_PROVIDER","Injector","parent","_parent","constructorOrToken","provider","_registry","resolved","_resolveToken","_resolveConstructor","_getProvider"],"mappings":"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"}