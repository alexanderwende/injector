{"version":3,"file":"index.esm.js","sources":["../src/annotations/metadata-keys.ts","../src/annotations/annotations.ts","../src/inject-token.ts","../src/decorators/inject.ts","../src/decorators/injectable.ts","../src/decorators/optional.ts","../src/factories/class-factory.ts","../src/factories/singleton-factory.ts","../src/factories/value-factory.ts","../src/providers/base-provider.ts","../src/providers/class-provider.ts","../src/providers/singleton-provider.ts","../src/providers/value-provider.ts","../src/injector.ts"],"sourcesContent":["/**\n * @internal\n */\nexport const DESIGN_TYPE = 'design:type';\n\n/**\n * @internal\n */\nexport const DESIGN_PARAMETER_TYPES = 'design:paramtypes';\n\n/**\n * @internal\n */\nexport const TOKEN = 'ioc:token';\n\n/**\n * @internal\n */\nexport const PARAMETERS = 'ioc:parameters';\n\n/**\n * @internal\n */\nexport const PROPERTIES = 'ioc:properties';\n","import { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\nimport * as ANNOTATION from './metadata-keys';\n\n/**\n * A dependency annotation describes a dependency that should be resolved by an injector\n *\n * @remarks\n * Most classes have dependencies, either in the form of constructor parameters or in\n * the form of properties which can be injected. When a provider is created for a class\n * it needs to know about the class's dependencies. The provider can obtain a map of the\n * class's dependencies by respectively calling {@link getParameterAnnotations} or\n * {@link getPropertyAnnotations} if the class was decorated as {@link injectable}. A\n * DependencyAnnotation does not contain a value itself, but rather a token which allows\n * the provider to resolve the class's dependency via the injector. This allows a great\n * deal of flexibility, especially when combined with child injectors.\n *\n * DependencyAnnotations are not only useful for class dependencies though. They can be\n * equally useful when creating simple factory providers, where the factories dependencies\n * should be resolved through an {@link InjectToken} at runtime.\n */\nexport class DependencyAnnotation<T = any> {\n\n    constructor (\n        public token: InjectToken<T> | Constructor<T>,\n        public optional: boolean = false) { }\n}\n\n/**\n * A map of constructor parameter dependency annotations\n */\nexport type ParameterAnnotations = Map<number, DependencyAnnotation>;\n\n/**\n * A map of class property dependency annotations\n */\nexport type PropertyAnnotations = Map<PropertyKey, DependencyAnnotation>;\n\n/**\n * Gets the {@link InjectToken} of a class\n *\n * @internal\n */\nexport const getTokenAnnotation = <T> (target: Constructor<T>): InjectToken<T> | undefined => {\n\n    return Reflect.getOwnMetadata(ANNOTATION.TOKEN, target);\n};\n\n/**\n * Sets the {@link InjectToken} of a class\n *\n * @internal\n */\nexport const setTokenAnnotation = <T> (target: Constructor<T>, token: InjectToken<T>): void => {\n\n    Reflect.defineMetadata(ANNOTATION.TOKEN, token, target);\n};\n\n/**\n * Gets the {@link DependencyAnnotation} of a constructor parameter\n *\n * @internal\n */\nexport const getParameterAnnotation = (target: Constructor, parameterIndex: number): DependencyAnnotation => {\n\n    ensureParameterAnnotations(target);\n\n    return (Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target) as ParameterAnnotations).get(parameterIndex)!;\n};\n\n/**\n * Updates a {@link DependencyAnnotation} of a constructor parameter with the values from the partial annotation\n *\n * @internal\n */\nexport const setParameterAnnotation = (\n    target: Constructor,\n    parameterIndex: number,\n    annotation: Partial<DependencyAnnotation>): void => {\n\n    ensureParameterAnnotations(target);\n\n    const annotations = Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target) as ParameterAnnotations;\n\n    Object.assign(annotations.get(parameterIndex), annotation);\n};\n\n/**\n * Gets the {@link ParameterAnnotations} of a class's constructor\n *\n * @internal\n */\nexport const getParameterAnnotations = (target: Constructor): ParameterAnnotations => {\n\n    ensureParameterAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target) as ParameterAnnotations;\n};\n\n/**\n * Gets the {@link DependencyAnnotation} of a class property\n *\n * @internal\n */\nexport const getPropertyAnnotation = (target: Constructor, propertyKey: PropertyKey): DependencyAnnotation => {\n\n    ensurePropertyAnnotation(target, propertyKey);\n\n    // we have to use a type cast as TypeScript currently doesn't support Symbols as index types\n    return (Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target) as PropertyAnnotations).get(propertyKey)!;\n};\n\n/**\n * Updates a {@link DependencyAnnotation} of a class property with the values from the partial annotation\n *\n * @internal\n */\nexport const setPropertyAnnotation = (\n    target: Constructor,\n    propertyKey: PropertyKey,\n    annotation: Partial<DependencyAnnotation>): void => {\n\n    ensurePropertyAnnotation(target, propertyKey);\n\n    const annotations = Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target) as PropertyAnnotations;\n\n    Object.assign(annotations.get(propertyKey), annotation);\n};\n\n/**\n * Gets the {@link PropertyAnnotations} of a class\n *\n * @internal\n */\nexport const getPropertyAnnotations = (target: Constructor): PropertyAnnotations => {\n\n    ensurePropertyAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target) as PropertyAnnotations;\n};\n\n\n\nconst ensureParameterAnnotations = (target: Constructor) => {\n\n    if (!Reflect.hasOwnMetadata(ANNOTATION.PARAMETERS, target)) {\n\n        const parameterTypes: Constructor[] = Reflect.getOwnMetadata(ANNOTATION.DESIGN_PARAMETER_TYPES, target) || [];\n        const parameterAnnotations: ParameterAnnotations = new Map(\n            parameterTypes.map(\n                (type, index) => [index, new DependencyAnnotation(type)] as [number, DependencyAnnotation]\n            ));\n\n        Reflect.defineMetadata(ANNOTATION.PARAMETERS, parameterAnnotations, target);\n    }\n};\n\nconst ensurePropertyAnnotation = (target: Constructor, propertyKey: PropertyKey) => {\n\n    const properties = getPropertyAnnotations(target);\n\n    if (!properties.has(propertyKey)) {\n\n        const propertyType = Reflect.getOwnMetadata(\n            ANNOTATION.DESIGN_TYPE,\n            target.prototype,\n            // we force a type cast here as reflection types the PropertyKey as string | symbol,\n            // at runtime numeric property keys work too\n            propertyKey as string | symbol\n        ) as InjectToken | Constructor;\n\n        properties.set(propertyKey, new DependencyAnnotation(propertyType));\n    }\n};\n\nconst ensurePropertyAnnotations = (target: Constructor) => {\n\n    if (!Reflect.hasOwnMetadata(ANNOTATION.PROPERTIES, target)) {\n\n        Reflect.defineMetadata(ANNOTATION.PROPERTIES, new Map(), target);\n    }\n};\n","/**\n * A token that represents a dependency\n *\n * @remarks\n * An {@link InjectToken} should be used to inject any type, which does not have a runtime\n * representation, e.g. an interface, callable type or a plain value. An {@link InjectToken}\n * is tied to a {@link Provider} using the {@link Injector.register} method.\n *\n * ```typescript\n * interface MessageService {\n *      getMessage (): string;\n * }\n *\n * interface MessageClientConfig {\n *      checkMessages: boolean;\n *      answerMessages: boolean;\n * }\n *\n * class FooMessageService implements MessageService {\n *      getMessage () { return 'foo'; }\n * }\n *\n * // use a generic type to tie the token to the interface type\n * const MESSAGE_SERVICE = new InjectToken<MessageService>('MessageService');\n * const CONFIG = new InjectToken<MessageClientConfig>('MessageClientConfig');\n *\n * const injector = new Injector();\n *\n * injector.register(MESSAGE_SERVICE, new ClassProvider(FooMessageService));\n * injector.register(CONFIG, new ValueProvider({ checkMessages: true, answerMessages: false }));\n *\n * injector.resolve(MESSAGE_SERVICE).getMessage(); // --> 'foo'\n * injector.resolve(CONFIG); // --> { checkMessages: true, answerMessages: false }\n * ```\n */\nexport class InjectToken<T = any> {\n\n    constructor (public description: string) { }\n}\n","import { getParameterAnnotation, getPropertyAnnotation, setParameterAnnotation, setPropertyAnnotation } from '../annotations';\nimport { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\n\n/**\n * Decorates a class property or constructor parameter as injection target\n *\n * @remarks\n * The inject decorator has two use cases:\n * - Injecting dependencies into class properties\n * - Injecting non-class dependencies through {@link InjectToken}s\n *\n * When used to inject class properties, it can be used without specifying an {@link InjectToken}.\n * The property type will be used as token and the injector will create a {@link ClassProvider} for\n * the type automatically.\n *\n * ```typescript\n * // decorate the dependency as injectable\n * @injectable()\n * class MessageService {\n *     getMessage () { return 'foo'; }\n * }\n *\n * // decorate the consumer as injectable\n * @injectable()\n * class MessageClient {\n *     // decorate the property you want to inject\n *     @inject()\n *     public service!: MessageService;\n * }\n * ```\n *\n * When used to inject non-class properties, an {@link InjectToken} needs to be provided.\n * An {@link InjectToken} can be used for property and parameter injection alike.\n *\n * ```typescript\n * // an interface describing the MessageService\n * interface MessageService {\n *     getMessage (): string;\n * }\n *\n * // an `InjectToken` representing the interface\n * // use a generic type to tie the token to the interface type\n * const MESSAGE_SERVICE = new InjectToken<MessageService>('MessageService');\n *\n * // a class implementing the MessageService interface - decorated as injectable\n * @injectable()\n * class FooMessageService implements MessageService {\n *     getMessage () { return 'foo'; }\n * }\n *\n * // decorate the consumer as injectable\n * @injectable()\n * class MessageClient {\n *     // inject the implementation by using the `InjectToken`\n *     constructor (@inject(MESSAGE_SERVICE) public service: MessageService) {}\n * }\n *\n * // create an `Injector` instance\n * const injector = new Injector();\n *\n * // tell the injector how to resolve the MESSAGE_SERVICE token\n * // we are using a `ClassProvider` here, but we could use other providers as well\n * injector.register(MESSAGE_SERVICE, new ClassProvider(FooMessageService));\n * ```\n *\n * @param injectToken - An {@link InjectToken} identifying the dependency to inject\n */\nexport const inject = <T> (injectToken?: InjectToken<T>) => {\n\n    return (target: Object, propertyKey: PropertyKey, parameterIndex?: number): void => {\n\n        const isParameterDecorator = typeof parameterIndex === 'number';\n\n        const token: InjectToken<T> | Constructor<T> = injectToken instanceof InjectToken\n            ? injectToken\n            : isParameterDecorator\n                ? getParameterAnnotation(target as Constructor, parameterIndex!).token\n                : getPropertyAnnotation(target.constructor as Constructor, propertyKey).token;\n\n        // TODO: This sets the token twice - once during the get (caused by ensure) and then by the set\n        if (isParameterDecorator) {\n\n            setParameterAnnotation(target as Constructor, parameterIndex!, { token });\n\n        } else {\n\n            setPropertyAnnotation(target.constructor as Constructor, propertyKey, { token });\n        }\n    };\n};\n","import { setTokenAnnotation } from '../annotations';\nimport { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\n\nexport const injectable = () => {\n\n    return (target: Constructor<object>) => {\n\n        const token = new InjectToken(target.name);\n\n        setTokenAnnotation(target, token);\n    };\n};\n","import { setParameterAnnotation, setPropertyAnnotation } from '../annotations';\nimport { Constructor } from '../utils';\n\nexport const optional = () => {\n\n    return (target: Object, propertyKey: string | symbol, parameterIndex?: number): void => {\n\n        if (typeof parameterIndex === 'number') {\n\n            // decorator is a parameter decorator\n            setParameterAnnotation(target as Constructor, parameterIndex, { optional: true });\n\n        } else {\n\n            // decorator is a property decorator\n            setPropertyAnnotation(target.constructor as Constructor, propertyKey, { optional: true });\n        }\n    };\n};\n","import { Constructor } from '../utils';\nimport { Factory } from './factory';\n\nexport interface ClassFactory<T> extends Factory<T> {\n    (...dependencies: any[]): T;\n}\n\nexport const createClassFactory = <T> (constructorFn: Constructor<T>): ClassFactory<T> => {\n\n    return (...dependencies: any[]) => {\n\n        return Reflect.construct(constructorFn, dependencies);\n    };\n};\n","import { Constructor } from '../utils';\nimport { Factory } from './factory';\n\nexport interface SingletonFactory<T> extends Factory<T> {\n    (...dependencies: any[]): T;\n}\n\nexport const createSingletonFactory = <T> (constructorFn: Constructor<T>): SingletonFactory<T> => {\n\n    let instance: T;\n\n    return (...dependencies: any[]) => {\n\n        if (!instance) instance = Reflect.construct(constructorFn, dependencies);\n\n        return instance;\n    };\n};\n","import { Factory } from './factory';\n\nexport interface ValueFactory<T> extends Factory<T> {\n    (): T;\n}\n\nexport const createValueFactory = <T> (value: T): ValueFactory<T> => {\n\n    return () => value;\n};\n","import { DependencyAnnotation } from '../annotations';\nimport { Factory } from '../factories';\nimport { Injector } from '../injector';\nimport { ParameterDependencies, PropertyDependencies, Provider } from './provider';\n\n/**\n * @internal\n */\nexport const PROVIDER_UNREGISTERED = new Error('Provider is not registered with an injector.');\n\n/**\n * The `BaseProvider` class\n *\n * @remarks\n * `BaseProvider` uses a factory function to provide a value. The provider's parameter dependencies\n * will be used to invoke the factory function. The provider's property dependencies will be set on\n * the factory function's return value. Each of the dependencies will be resolved using an\n * `Injector` instance which must be passed to the provider's {@link provide} method.\n *\n * ```typescript\n * @injectable()\n * class Foo {}\n *\n * @injectable()\n * class Bar {}\n *\n * const factory = (foo: Foo, bar: Bar) => ({ foo: foo, bar: bar });\n *\n * const provider = new BaseProvider(factory, [\n *      new DependencyAnnotation(Foo),\n *      new DependencyAnnotation(Bar)\n * ]);\n *\n * const injector = new Injector();\n *\n * provider.provide(injector);\n *\n * // or more naturally...\n *\n * interface FooBar {\n *      foo: Foo;\n *      bar: Bar;\n * }\n *\n * const token = new InjectToken<FooBar>('FooBar');\n *\n * injector.register(token, provider);\n *\n * injector.resolve(token)!;\n * ```\n */\nexport class BaseProvider<T> implements Provider<T> {\n\n    public injector: Injector | undefined;\n    public parameters: Map<number, DependencyAnnotation | any>;\n    public properties: Map<PropertyKey, DependencyAnnotation | any>;\n\n    /**\n     * The `BaseProvider` constructor\n     *\n     * @param factory - The provider's factory function\n     * @param parameters - The parameter dependencies of the factory function\n     * @param properties - The property dependencies of the value returned from the factory function\n     */\n    constructor (\n        public factory: Factory<T>,\n        parameters: ParameterDependencies = new Map(),\n        properties: PropertyDependencies = new Map()) {\n\n        // TODO: update to TypeScript 3.4 for better support of map() --> we can then remove the assertion\n        this.parameters = !(parameters instanceof Map)\n            ? new Map(parameters.map((value, index) => [index, value] as [number, any]))\n            : parameters;\n\n        this.properties = !(properties instanceof Map)\n            ? new Map([\n                ...Object.getOwnPropertyNames(properties).map(key => [key, properties[key]]) as [string | number, any],\n                ...Object.getOwnPropertySymbols(properties).map(symbol => [symbol, properties[symbol as any]])\n            ])\n            : properties;\n    }\n\n    /**\n     * Get the provider's provided value\n     *\n     * @param injector - The injector to use to resolve the provider's dependencies\n     * @returns The provider's provided value\n     */\n    provide (injector?: Injector): T {\n\n        if (!injector) injector = this.injector;\n\n        if (!injector) throw PROVIDER_UNREGISTERED;\n\n        const parameters = this.resolveParameters(injector);\n\n        const properties = this.resolveProperties(injector);\n\n        return this.createValue(parameters, properties);\n    }\n\n    /**\n     * Resolves the parameter dependencies for the factory\n     *\n     * @remarks\n     * If a parameter dependency is a {@link DependencyAnnotation} it will be resolved\n     * from the current injector. Otherwise its value will be used to resolve the\n     * dependency.\n     *\n     * @param injector - The current injector that runs the provider\n     * @returns An array of resolved parameter dependencies\n     */\n    protected resolveParameters (injector: Injector): any[] {\n\n        const parameters: any[] = [];\n\n        this.parameters.forEach((parameter, index) => {\n            parameters[index] = (parameter instanceof DependencyAnnotation)\n                ? injector.resolve(parameter.token, parameter.optional)\n                : parameter;\n        });\n\n        return parameters;\n    }\n\n    /**\n     * Resolves the property dependencies for the factory\n     *\n     * @remarks\n     * If a property dependency is a {@link DependencyAnnotation} it will be resolved\n     * from the current injector. Otherwise its value will be used to resolve the\n     * dependency.\n     *\n     * @param injector - The current injector that runs the provider\n     * @returns An object of resolved property dependencies\n     */\n    protected resolveProperties (injector: Injector): any {\n\n        const properties: any = {};\n\n        this.properties.forEach((property, key) => {\n            properties[key] = (property instanceof DependencyAnnotation)\n                ? injector.resolve(property.token, property.optional)\n                : property;\n        });\n\n        return properties;\n    }\n\n    /**\n     * Creates the provider's provided value by invoking the factory\n     *\n     * @param parameters - The parameter dependencies of the factory\n     * @param properties - The property dependencies of the instance returned from the factory\n     * @returns The value created by the provider's factory\n     */\n    protected createValue (parameters: any[] = [], properties: any = {}): T {\n\n        const value = this.factory(...parameters);\n\n        return (value instanceof Object) ? Object.assign(value, properties) : value;\n    }\n}\n","import { getParameterAnnotations, getPropertyAnnotations } from '../annotations';\nimport { createClassFactory } from '../factories';\nimport { Constructor } from '../utils';\nimport { BaseProvider } from './base-provider';\nimport { ParameterDependencies, PropertyDependencies } from './provider';\n\n/**\n * A provider for class instances\n *\n * @remarks\n * The `ClassProvider` provides instances of classes. It can be created by passing a reference to a class\n * to its constructor. `ClassProvider` automatically analyzes parameter and property dependencies of the\n * class and resolves them when creating instances.\n *\n * ```typescript\n * @injectable()\n * class Foo { }\n *\n * @injectable()\n * class Bar { }\n *\n * @injectable()\n * class FooBar {\n *\n *     @optional()\n *     @inject()\n *     bar!: Bar;\n *\n *     constructor (public foo: Foo) { }\n * }\n *\n * const provider = new ClassProvider(FooBar);\n * const injector = new Injector();\n *\n * injector.register(FooBar, provider);\n *\n * const fooBar = injector.resolve(FooBar)!;\n * ```\n */\nexport class ClassProvider<T> extends BaseProvider<T> {\n\n    constructor (\n        constructorFn: Constructor<T>,\n        parameters?: ParameterDependencies,\n        properties?: PropertyDependencies) {\n\n        super(\n            createClassFactory(constructorFn),\n            parameters || getParameterAnnotations(constructorFn),\n            properties || getPropertyAnnotations(constructorFn)\n        );\n    }\n}\n","import { ClassProvider } from './class-provider';\nimport { Injector } from '../injector';\n\n/**\n * A provider for singleton class instances\n *\n * @remarks\n * The `SingletonProvidr` caches the first instance of a class it creates and subsequently\n * returns the cached instance instead of creating new instances.\n */\nexport class SingletonProvider<T> extends ClassProvider<T> {\n\n    protected _instance: T | undefined;\n\n    provide (injector?: Injector): T {\n\n        if (!this._instance) this._instance = super.provide(injector);\n\n        return this._instance;\n    }\n}\n","import { createValueFactory } from '../factories';\nimport { BaseProvider } from './base-provider';\n\n/**\n * A provider for static values\n *\n * @remarks\n * The `ValueProvider` provides an already existing value and therefore has no dependencies.\n * This is useful for providing primitive values, configuration objects or any value that\n * does not need to be instantiated.\n *\n * ```typescript\n * const CONFIG = {\n *      receiveMessages: true,\n *      answerMessages: false,\n *      channelId: 'some_id'\n * }\n *\n * const token = new InjectToken('CONFIG');\n *\n * const injector = new injector();\n *\n * injector.register(token, new ValueProvider(CONFIG));\n *\n * injector.resolve(token)!; // --> { receiveMessages: true, answerMessages: false, channelId: 'some_id' }\n * ```\n */\nexport class ValueProvider<T> extends BaseProvider<T> {\n\n    constructor (value: T) {\n\n        super(createValueFactory(value));\n    }\n}\n","import { getTokenAnnotation } from './annotations';\nimport { injectable } from './decorators';\nimport { InjectToken } from './inject-token';\nimport { ClassProvider, Provider, ValueProvider } from './providers';\nimport { Constructor } from './utils';\n\n/**\n * @internal\n */\nexport const CLASS_NOT_PROVIDABLE = (constructorFn: Constructor) =>\n    new Error(`Class '${ constructorFn.name }' has not been decorated as injectable and cannot be provided.`);\n\n/**\n * @internal\n */\nexport const CLASS_NOT_RESOLVABLE = (constructorFn: Constructor) =>\n    new Error(`Class '${ constructorFn.name }' has not been decorated as injectable and cannot be resolved.`);\n\n/**\n * @internal\n */\nexport const NO_PROVIDER = (token: InjectToken) =>\n    new Error(`No provider has been found for the requested token '${ token.description }'.`);\n\n\n/**\n * A configuration interface for providers\n */\nexport interface ProviderConfiguration<T = any> {\n    token: InjectToken<T> | Constructor<T>;\n    provider: Provider<T>;\n}\n\n/**\n * A configuration interface for Injector\n */\nexport interface InjectorConfiguration {\n    /**\n     * The default provider used by the injector\n     *\n     * @remarks\n     * Injector will use the default provider as provider for {@link injectable} classes, which have\n     * no provider registered explicitly. A default provider needs to accept a reference to the class\n     * it is created for as only constructor argument. {@link ClassProvider} and {@link SingletonProvider}\n     * can be used as default providers. Alternatively a custom provider with the same interface can\n     * be created and configured.\n     *\n     * The default value for this option is {@link ClassProvider}.\n     */\n    defaultProvider: { new <T = any>(constructor: Constructor<T>): Provider<T> };\n}\n\n// TODO: update docs\n/**\n * The injector class\n *\n * @remarks\n * - can provide itself\n * - can create child injectors\n */\n@injectable()\nexport class Injector {\n\n    private _registry: Map<InjectToken<any>, Provider<any>> = new Map();\n\n    private _parent: Injector | null = null;\n\n    private _config: InjectorConfiguration = { defaultProvider: ClassProvider };\n\n    /**\n     * Creates an injector instance\n     *\n     * @remarks\n     * A child injector can be created by passing the parent injector as a constructor argument.\n     *\n     * ```typescript\n     * const parentInjector = new Injector();\n     * const childInjector = new Injector(parentInjector);\n     * ```\n     */\n    constructor (parent?: Injector);\n    /**\n     * Creates an injector instance\n     *\n     * @remarks\n     * An injector can be configured with a default provider.\n     *\n     * @see {@link InjectorConfiguration#defaultProvider}\n     *\n     * ```typescript\n     * // configures the injector to use the SingletonProvider for injectable classes by default\n     * const injector = new Injector({ defaultProvider: SingletonProvider });\n     * ```\n     */\n    constructor (config?: Partial<InjectorConfiguration>);\n    /**\n     * Creates an injector instance\n     *\n     * @remarks\n     * A child injector can be configured with a default provider.\n     *\n     * @see {@link InjectorConfiguration#defaultProvider}\n     *\n     * ```typescript\n     * const parentInjector = new Injector();\n     *\n     * // configures the injector to use the SingletonProvider for injectable classes by default\n     * const childInjector = new Injector(parentInjector, { defaultProvider: SingletonProvider });\n     * ```\n     */\n    constructor (parent?: Injector, config?: Partial<InjectorConfiguration>);\n    constructor (...args: any[]) {\n\n        const parent = (args.length && (args[0] instanceof Injector))\n            ? args[0]\n            : undefined;\n\n        const config = (args.length && !(args[0] instanceof Injector))\n            ? args[0]\n            : args[1] ? args[1] : undefined;\n\n        if (parent) {\n            // if a parent provider was given, store the reference\n            this._parent = parent;\n            // and inherit the parent provider's configuration\n            this._config = { ...parent._config };\n        }\n\n        if (config) {\n            // if a configuration was given, extend the default configuration\n            this._config = { ...this._config, ...config };\n        }\n\n        // register the Injector instance itself\n        this.register(Injector, new ValueProvider(this));\n    }\n\n    // TODO: add an overload which allows to register multiple providers?\n    // providers.forEach(({ token, provider }) => this.register(token, provider));\n    /**\n     * Register a provider for a dependency with the injector\n     *\n     * @param constructorOrToken - The class or {@link InjectToken} for which to register the provider\n     * @param provider - The {@link Provider} which will be used to resolve the class or token\n     */\n    register<T> (constructorOrToken: Constructor<T> | InjectToken<T>, provider: Provider<T>) {\n\n        const token: InjectToken<T> | undefined = constructorOrToken instanceof InjectToken\n            ? constructorOrToken\n            : getTokenAnnotation(constructorOrToken);\n\n        // class was not decorated with @injectable, throw\n        if (!token) throw CLASS_NOT_PROVIDABLE(constructorOrToken as Constructor);\n\n        provider.injector = this;\n\n        this._registry.set(token, provider);\n    }\n\n    /**\n     * Resolve a dependency\n     *\n     * @param target - The class or {@link InjectToken} to resolve\n     * @param optional - Should the dependency be optional. If `true` the injector will not throw an\n     * error if it cannot resolve the dependency and returns `undefined`. If `false` the injector will\n     * throw an error if the dependency cannot be resolved.\n     */\n    resolve<T> (target: Constructor<T> | InjectToken<T>, optional = false): T | undefined {\n\n        let resolved: T | undefined;\n\n        if (target instanceof InjectToken) {\n\n            resolved = this._resolveToken(target, optional);\n\n        } else {\n\n            resolved = this._resolveConstructor(target, optional);\n        }\n\n        return resolved;\n    }\n\n    /**\n     * @internal\n     */\n    protected _resolveConstructor<T> (constructorFn: Constructor<T>, optional = false): T | undefined {\n\n        const token: InjectToken<T> | undefined = getTokenAnnotation(constructorFn);\n\n        // class was not decorated with @injectable, throw if not optional\n        if (!token) {\n\n            if (!optional) throw CLASS_NOT_RESOLVABLE(constructorFn);\n\n            return undefined;\n        }\n\n        // class has no provider yet, we create one\n        if (!this._getProvider(token)) {\n\n            this.register(token, new this._config.defaultProvider(constructorFn));\n        }\n\n        return this._resolveToken(token, optional);\n    }\n\n    /**\n     * @internal\n     */\n    protected _resolveToken<T> (token: InjectToken<T>, optional = false): T | undefined {\n\n        const provider = this._getProvider(token);\n\n        // token has no provider, throw if not optional\n        if (!provider) {\n\n            if (!optional) throw NO_PROVIDER(token);\n\n            return undefined;\n        }\n\n        return provider!.provide(this);\n    }\n\n    /**\n     * @internal\n     */\n    protected _getProvider<T> (token: InjectToken<T>): Provider<T> | undefined {\n\n        if (this._registry.has(token)) {\n\n            return this._registry.get(token);\n\n        } else if (this._parent) {\n\n            return this._parent._getProvider(token);\n        }\n    }\n}\n"],"names":["PARAMETERS","PROPERTIES","DependencyAnnotation","[object Object]","token","optional","this","getTokenAnnotation","target","Reflect","getOwnMetadata","setTokenAnnotation","defineMetadata","getParameterAnnotation","parameterIndex","ensureParameterAnnotations","ANNOTATION.PARAMETERS","get","setParameterAnnotation","annotation","annotations","Object","assign","getParameterAnnotations","getPropertyAnnotation","propertyKey","ensurePropertyAnnotation","ANNOTATION.PROPERTIES","setPropertyAnnotation","getPropertyAnnotations","ensurePropertyAnnotations","hasOwnMetadata","parameterTypes","parameterAnnotations","Map","map","type","index","properties","has","propertyType","prototype","set","InjectToken","description","inject","injectToken","isParameterDecorator","constructor","injectable","name","createClassFactory","constructorFn","dependencies","construct","createSingletonFactory","instance","createValueFactory","value","PROVIDER_UNREGISTERED","Error","BaseProvider","factory","parameters","getOwnPropertyNames","key","getOwnPropertySymbols","symbol","injector","resolveParameters","resolveProperties","createValue","forEach","parameter","resolve","property","ClassProvider","super","SingletonProvider","_instance","provide","ValueProvider","CLASS_NOT_PROVIDABLE","CLASS_NOT_RESOLVABLE","NO_PROVIDER","Injector","args","defaultProvider","parent","length","Injector_1","undefined","config","_parent","_config","register","constructorOrToken","provider","_registry","resolved","_resolveToken","_resolveConstructor","_getProvider"],"mappings":"AAGO,MAeMA,EAAa,iBAKbC,EAAa,iBCF1B,MAAaC,EAETC,YACWC,EACAC,GAAoB,GADpBC,WAAAF,EACAE,cAAAD,SAkBFE,EAA0BC,GAE5BC,QAAQC,eDhCE,YCgC+BF,GAQvCG,EAAqB,CAAKH,EAAwBJ,KAE3DK,QAAQG,eD1CS,YC0CwBR,EAAOI,IAQvCK,EAAyB,CAACL,EAAqBM,KAExDC,EAA2BP,GAEnBC,QAAQC,eAAeM,EAAuBR,GAAiCS,IAAIH,IAQlFI,EAAyB,CAClCV,EACAM,EACAK,KAEAJ,EAA2BP,GAE3B,MAAMY,EAAcX,QAAQC,eAAeM,EAAuBR,GAElEa,OAAOC,OAAOF,EAAYH,IAAIH,GAAiBK,IAQtCI,EAA2Bf,IAEpCO,EAA2BP,GAEpBC,QAAQC,eAAeM,EAAuBR,IAQ5CgB,EAAwB,CAAChB,EAAqBiB,KAEvDC,EAAyBlB,EAAQiB,GAGzBhB,QAAQC,eAAeiB,EAAuBnB,GAAgCS,IAAIQ,IAQjFG,EAAwB,CACjCpB,EACAiB,EACAN,KAEAO,EAAyBlB,EAAQiB,GAEjC,MAAML,EAAcX,QAAQC,eAAeiB,EAAuBnB,GAElEa,OAAOC,OAAOF,EAAYH,IAAIQ,GAAcN,IAQnCU,EAA0BrB,IAEnCsB,EAA0BtB,GAEnBC,QAAQC,eAAeiB,EAAuBnB,IAKnDO,EAA8BP,IAEhC,IAAKC,QAAQsB,eAAef,EAAuBR,GAAS,CAExD,MAAMwB,EAAgCvB,QAAQC,eD3IhB,oBC2IkEF,IAAW,GACrGyB,EAA6C,IAAIC,IACnDF,EAAeG,IACX,CAACC,EAAMC,IAAU,CAACA,EAAO,IAAInC,EAAqBkC,MAG1D3B,QAAQG,eAAeI,EAAuBiB,EAAsBzB,KAItEkB,EAA2B,CAAClB,EAAqBiB,KAEnD,MAAMa,EAAaT,EAAuBrB,GAE1C,IAAK8B,EAAWC,IAAId,GAAc,CAE9B,MAAMe,EAAe/B,QAAQC,eDhKV,cCkKfF,EAAOiC,UAGPhB,GAGJa,EAAWI,IAAIjB,EAAa,IAAIvB,EAAqBsC,MAIvDV,EAA6BtB,IAE1BC,QAAQsB,eAAeJ,EAAuBnB,IAE/CC,QAAQG,eAAee,EAAuB,IAAIO,IAAO1B,IChJjE,MAAamC,EAETxC,YAAoByC,GAAAtC,iBAAAsC,SC+BXC,EAAcC,GAEhB,CAACtC,EAAgBiB,EAA0BX,KAE9C,MAAMiC,EAAiD,iBAAnBjC,EAE9BV,EAAyC0C,aAAuBH,EAChEG,EACAC,EACIlC,EAAuBL,EAAuBM,GAAiBV,MAC/DoB,EAAsBhB,EAAOwC,YAA4BvB,GAAarB,MAG5E2C,EAEA7B,EAAuBV,EAAuBM,EAAiB,CAAEV,MAAAA,IAIjEwB,EAAsBpB,EAAOwC,YAA4BvB,EAAa,CAAErB,MAAAA,KCnFvE6C,EAAa,IAEdzC,IAEJ,MAAMJ,EAAQ,IAAIuC,EAAYnC,EAAO0C,MAErCvC,EAAmBH,EAAQJ,ICPtBC,EAAW,IAEb,CAACG,EAAgBiB,EAA8BX,KAEpB,iBAAnBA,EAGPI,EAAuBV,EAAuBM,EAAgB,CAAET,UAAU,IAK1EuB,EAAsBpB,EAAOwC,YAA4BvB,EAAa,CAAEpB,UAAU,KCRjF8C,EAA0BC,GAE5B,IAAIC,IAEA5C,QAAQ6C,UAAUF,EAAeC,GCJnCE,EAA8BH,IAEvC,IAAII,EAEJ,MAAO,IAAIH,KAEFG,IAAUA,EAAW/C,QAAQ6C,UAAUF,EAAeC,IAEpDG,ICTFC,EAA0BC,GAE5B,IAAMA,ECAJC,EAAwB,IAAIC,MAAM,gDA2C/C,MAAaC,EAaT1D,YACW2D,EACPC,EAAoC,IAAI7B,IACxCI,EAAmC,IAAIJ,KAFhC5B,aAAAwD,EAKPxD,KAAKyD,WAAeA,aAAsB7B,IAEpC6B,EADA,IAAI7B,IAAI6B,EAAW5B,IAAI,CAACuB,EAAOrB,IAAU,CAACA,EAAOqB,KAGvDpD,KAAKgC,WAAeA,aAAsBJ,IAKpCI,EAJA,IAAIJ,IAAI,IACHb,OAAO2C,oBAAoB1B,GAAYH,IAAI8B,GAAO,CAACA,EAAK3B,EAAW2B,QACnE5C,OAAO6C,sBAAsB5B,GAAYH,IAAIgC,GAAU,CAACA,EAAQ7B,EAAW6B,OAW1FhE,QAASiE,GAIL,GAFKA,IAAUA,EAAW9D,KAAK8D,WAE1BA,EAAU,MAAMT,EAErB,MAAMI,EAAazD,KAAK+D,kBAAkBD,GAEpC9B,EAAahC,KAAKgE,kBAAkBF,GAE1C,OAAO9D,KAAKiE,YAAYR,EAAYzB,GAc9BnC,kBAAmBiE,GAEzB,MAAML,EAAoB,GAQ1B,OANAzD,KAAKyD,WAAWS,QAAQ,CAACC,EAAWpC,KAChC0B,EAAW1B,GAAUoC,aAAqBvE,EACpCkE,EAASM,QAAQD,EAAUrE,MAAOqE,EAAUpE,UAC5CoE,IAGHV,EAcD5D,kBAAmBiE,GAEzB,MAAM9B,EAAkB,GAQxB,OANAhC,KAAKgC,WAAWkC,QAAQ,CAACG,EAAUV,KAC/B3B,EAAW2B,GAAQU,aAAoBzE,EACjCkE,EAASM,QAAQC,EAASvE,MAAOuE,EAAStE,UAC1CsE,IAGHrC,EAUDnC,YAAa4D,EAAoB,GAAIzB,EAAkB,IAE7D,MAAMoB,EAAQpD,KAAKwD,WAAWC,GAE9B,OAAQL,aAAiBrC,OAAUA,OAAOC,OAAOoC,EAAOpB,GAAcoB,SCzHjEkB,UAAyBf,EAElC1D,YACIiD,EACAW,EACAzB,GAEAuC,MACI1B,EAAmBC,GACnBW,GAAcxC,EAAwB6B,GACtCd,GAAcT,EAAuBuB,WCvCpC0B,UAA6BF,EAItCzE,QAASiE,GAIL,OAFK9D,KAAKyE,YAAWzE,KAAKyE,UAAYF,MAAMG,QAAQZ,IAE7C9D,KAAKyE,iBCSPE,UAAyBpB,EAElC1D,YAAauD,GAETmB,MAAMpB,EAAmBC,iBCtBpBwB,EAAwB9B,GACjC,IAAIQ,gBAAiBR,EAAcF,sEAK1BiC,EAAwB/B,GACjC,IAAIQ,gBAAiBR,EAAcF,sEAK1BkC,EAAehF,GACxB,IAAIwD,6DAA8DxD,EAAMwC,qBAuC/DyC,IAAb,MAkDIlF,eAAgBmF,GAhDRhF,eAAkD,IAAI4B,IAEtD5B,aAA2B,KAE3BA,aAAiC,CAAEiF,gBAAiBX,GA8CxD,MAAMY,EAAUF,EAAKG,QAAWH,EAAK,aAAcI,EAC7CJ,EAAK,QACLK,EAEAC,GAAUN,EAAKG,QAAYH,EAAK,aAAcI,EAE9CJ,EAAK,GAAKA,EAAK,QAAKK,EADpBL,EAAK,GAGPE,IAEAlF,KAAKuF,QAAUL,EAEflF,KAAKwF,yBAAeN,EAAOM,UAG3BF,IAEAtF,KAAKwF,yBAAexF,KAAKwF,QAAYF,IAIzCtF,KAAKyF,SAASL,EAAU,IAAIT,EAAc3E,OAW9CH,SAAa6F,EAAqDC,GAE9D,MAAM7F,EAAoC4F,aAA8BrD,EAClEqD,EACAzF,EAAmByF,GAGzB,IAAK5F,EAAO,MAAM8E,EAAqBc,GAEvCC,EAAS7B,SAAW9D,KAEpBA,KAAK4F,UAAUxD,IAAItC,EAAO6F,GAW9B9F,QAAYK,EAAyCH,GAAW,GAE5D,IAAI8F,EAWJ,OAPIA,EAFA3F,aAAkBmC,EAEPrC,KAAK8F,cAAc5F,EAAQH,GAI3BC,KAAK+F,oBAAoB7F,EAAQH,GAS1CF,oBAAwBiD,EAA+B/C,GAAW,GAExE,MAAMD,EAAoCG,EAAmB6C,GAG7D,GAAKhD,EAaL,OALKE,KAAKgG,aAAalG,IAEnBE,KAAKyF,SAAS3F,EAAO,IAAIE,KAAKwF,QAAQP,gBAAgBnC,IAGnD9C,KAAK8F,cAAchG,EAAOC,GAX7B,IAAKA,EAAU,MAAM8E,EAAqB/B,GAiBxCjD,cAAkBC,EAAuBC,GAAW,GAE1D,MAAM4F,EAAW3F,KAAKgG,aAAalG,GAGnC,GAAK6F,EAOL,OAAOA,EAAUjB,QAAQ1E,MALrB,IAAKD,EAAU,MAAM+E,EAAYhF,GAW/BD,aAAiBC,GAEvB,OAAIE,KAAK4F,UAAU3D,IAAInC,GAEZE,KAAK4F,UAAUjF,IAAIb,GAEnBE,KAAKuF,QAELvF,KAAKuF,QAAQS,aAAalG,QAF9B,IA7KFiF,yUADZpC,gJACYoC"}