{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/annotations/metadata-keys.ts","webpack:///./src/annotations/index.ts","webpack:///./src/decorators/inject.ts","webpack:///./src/inject-token.ts","webpack:///./src/decorators/injectable.ts","webpack:///./src/decorators/optional.ts","webpack:///./src/decorators/index.ts","webpack:///./src/factories/class-factory.ts","webpack:///./src/factories/singleton-factory.ts","webpack:///./src/factories/value-factory.ts","webpack:///./src/providers/base-provider.ts","webpack:///./src/providers/class-provider.ts","webpack:///./src/providers/singleton-provider.ts","webpack:///./src/providers/value-provider.ts","webpack:///./src/injector.ts","webpack:///./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","DESIGN_TYPE","DESIGN_PARAMETER_TYPES","TOKEN","PARAMETERS","PROPERTIES","getTokenAnnotation","target","Reflect","getOwnMetadata","setTokenAnnotation","token","defineMetadata","getParameterAnnotation","parameterIndex","ensureParameterAnnotations","getParameterAnnotations","hasOwnMetadata","parameterAnnotations","map","type","createParameterAnnotation","getPropertyAnnotation","propertyKey","ensurePropertyAnnotation","getPropertyAnnotations","ensurePropertyAnnotations","properties","createPropertyAnnotation","optional","inject","constructor","inject_token_InjectToken","[object Object]","isConstructor","this","for","description","isSymbol","toString","injectable","optional_optional","constructorFn","Function","symbol","createClassFactory","dependencies","createSingletonFactory","instance","createValueFactory","PROVIDER_UNREGISTERED","Error","BaseProvider","factory","injector","_resolveDependencies","_resolveProperties","_createValue","assign","dependency","resolve","entries","reduce","result","class_provider_ClassProvider","super","singleton_provider_SingletonProvider","_instance","provide","value_provider_ValueProvider","CLASS_NOT_INJECTABLE","NO_PROVIDER","injector_Injector","_registry","Map","constructorOrToken","provider","set","resolved","_resolveToken","_resolveConstructor","has","__webpack_exports__","metadata_keys_namespaceObject"],"mappings":"aACA,IAAAA,EAAA,GAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,GAAA,CACAG,EAAAH,EACAI,GAAA,EACAH,QAAA,IAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,EAAA,CAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,eAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,YAAA,CAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,KAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,GAIAlC,IAAAmC,EAAA,8QClFO,MAAMC,EAAyB,cACzBC,EAAyB,oBAEzBC,EAAkB,YAClBC,EAAkB,iBAClBC,EAAkB,iBCWlBC,EAA0BC,GAE5BC,QAAQC,eAAeN,EAAkBI,GAGvCG,EAAqB,CAAKH,EAAwBI,KAE3DH,QAAQI,eAAeT,EAAkBQ,EAAOJ,IAGvCM,EAAyB,CAACN,EAAqBO,KAExDC,EAA2BR,GAEpBC,QAAQC,eAAeL,EAAuBG,GAAQO,IAGpDE,EAA2BT,IAEpCQ,EAA2BR,GAEpBC,QAAQC,eAAeL,EAAuBG,IAG5CQ,EAA8BR,IAEvC,IAAKC,QAAQS,eAAeb,EAAuBG,GAAS,CAExD,MACMW,GAD8CV,QAAQC,eAAeP,EAAmCK,IAAW,IACtDY,IAAIC,GAAQC,EAA0BD,IAEzGZ,QAAQI,eAAeR,EAAuBc,EAAsBX,KAI/De,EAAwB,CAACf,EAAqBgB,KAEvDC,EAAyBjB,EAAQgB,GAE1Bf,QAAQC,eAAeJ,EAAuBE,GAAQgB,IAGpDE,EAA0BlB,IAEnCmB,EAA0BnB,GAEnBC,QAAQC,eAAeJ,EAAuBE,IAG5CmB,EAA6BnB,IAEjCC,QAAQS,eAAeZ,EAAuBE,IAE/CC,QAAQI,eAAeP,EAAuB,GAAIE,IAI7CiB,EAA2B,CAACjB,EAAqBgB,KAE1DG,EAA0BnB,GAE1B,MAAMoB,EAAoDnB,QAAQC,eAAeJ,EAAuBE,GAEnGoB,EAAW7B,eAAeyB,KAE3BI,EAAWJ,GAAeK,EAAyBpB,QAAQC,eAAeR,EAAwBM,EAAOV,UAAW0B,MAI/GF,EAA4B,CAAKV,EAAwCkB,GAAW,KAAkC,CAC/HlB,MAAUA,EACVkB,SAAUA,IAGDD,EAA2B,CAAKjB,EAAwCkB,GAAW,KAAiC,CAC7HlB,MAAUA,EACVkB,SAAUA,ICxFDC,EAAcnB,GAEhB,CAACJ,EAAgBgB,EAA8BT,KAElD,GAA8B,iBAAnBA,EAA6B,CAGRD,EAAuBN,EAA4BO,GAE3DH,MAAQA,MAIzB,CAGwBW,EAAsBf,EAAOwB,YAAiCR,GAEtEZ,MAAQA,ICpBhC,MAAMqB,EAMTC,YAAa/C,GAELgD,EAAchD,IAEdiD,KAAKjD,MAAcF,OAAOoD,IAAIlD,EAAMV,MACpC2D,KAAKE,YAAcnD,EAAMV,MAElB8D,EAASpD,IAEhBiD,KAAKjD,MAAcA,EACnBiD,KAAKE,YAAcnD,EAAMqD,aAIzBJ,KAAKjD,MAAcF,OAAOoD,IAAIlD,GAC9BiD,KAAKE,YAAcnD,ICnBxB,MAAMsD,EAAa,IAEdjC,IAEJ,MAAMI,EAAQ,IAAIqB,EAAYzB,GAE9BG,EAAmBH,EAAQI,ICPtB8B,EAAW,IAEb,CAAClC,EAAgBgB,EAA8BT,KAElD,GAA8B,iBAAnBA,EAA6B,CAGRD,EAAuBN,EAA4BO,GAE3De,UAAW,MAE5B,CAGwBP,EAAsBf,EAAOwB,YAAiCR,GAEtEM,UAAW,ICjB7BK,EAAqBQ,GAEvBA,aAAyBC,UAAYD,EAAc7C,WAAa6C,EAAc7C,UAAUkC,cAAgBW,EAGtGJ,EAAYM,GAEI,iBAAXA,ECFLC,EAA0BH,GAE5B,IAAII,IAIA,IAAIJ,KAAiBI,GCNvBC,EAA8BL,IAEvC,IAAIM,EAEJ,MAAO,IAAIF,KAEFE,IAAUA,EAAW,IAAIN,KAAiBI,IAExCE,ICTFC,EAA0B/D,GAE5B,IAAMA,ECHJgE,EAAwB,IAAIC,MAAM,gDAExC,MAAMC,EAITnB,YAAoBoB,EACAP,EAAoD,GACpDnB,EAAoD,IAFpDQ,KAAAkB,UACAlB,KAAAW,eACAX,KAAAR,aAEpBM,UAEI,IAAKE,KAAKmB,SAAU,MAAMJ,EAO1B,MAAMJ,EAAeX,KAAKoB,uBAMpB5B,EAAaQ,KAAKqB,qBAMxB,OAAOrB,KAAKsB,aAAaX,EAAcnB,GAGjCM,aAAca,EAAqBnB,GAEzC,MAAMzC,EAAQiD,KAAKkB,WAAWP,GAE9B,OAAQ5D,aAAiBP,OAAUA,OAAO+E,OAAOxE,EAAOyC,GAAczC,EAGhE+C,uBAEN,OAAOE,KAAKW,aAAa3B,IAAIwC,GAAcxB,KAAKmB,SAAUM,QAAQD,EAAWhD,MAAOgD,EAAW9B,WAGzFI,qBAEN,OAAOtD,OAAOkF,QAAQ1B,KAAKR,YAAYmC,OAAO,CAACC,GAASvE,EAAKN,MAEzD6E,EAAOvE,GAAO2C,KAAKmB,SAAUM,QAAQ1E,EAAMyB,MAAOzB,EAAM2C,UAEjDkC,GAER,KCtDJ,MAAMC,UAAyBZ,EAElCnB,YAAaS,EACAI,EACAnB,GAETsC,MACIpB,EAAmBH,GACnBI,GAAgB9B,EAAwB0B,GACxCf,GAAcF,EAAuBiB,KCZ1C,MAAMwB,UAA6BF,EAItC/B,UAII,OAFKE,KAAKgC,YAAWhC,KAAKgC,UAAYF,MAAMG,WAErCjC,KAAKgC,WCPb,MAAME,UAAyBjB,EAElCnB,YAAa/C,GAET+E,MAAMhB,EAAmB/D,KCF1B,MAAMoF,EAAwB5B,GAA+B,IAAIS,gBAAgBT,EAAclE,sEACzF+F,EAAwB5D,GAAuB,IAAIwC,6DAA6DxC,EAAM0B,iBAE5H,MAAMmC,EAAbvC,cAEYE,KAAAsC,UAAkD,IAAIC,IAE9DzC,QAAY0C,EAAqDC,GAE7D,MAAMjE,EAAwBgE,aAA8B3C,EAC9B2C,EACArE,EAAmBqE,GAGjD,IAAKhE,EAAO,MAAM2D,EAAqBK,GAEvCC,EAAStB,SAAWnB,KAEpBA,KAAKsC,UAAUI,IAAIlE,EAAOiE,GAG9B3C,QAAY1B,EAAyCsB,GAAW,GAE5D,IAAIiD,EAiBJ,OAVIA,EAHAvE,aAAkByB,EAGPG,KAAK4C,cAAcxE,EAAQsB,GAK3BM,KAAK6C,oBAAoBzE,EAAQsB,GAQ1CI,oBAAwBS,EAA+Bb,GAAW,GAExE,MAAMlB,EAAwBL,EAAmBoC,GAGjD,IAAK/B,EAAO,MAAM2D,EAAqB5B,GAKvC,OAFKP,KAAKsC,UAAUQ,IAAItE,IAAQwB,KAAKiC,QAAQzD,EAAO,IAAIqD,EAActB,IAE/DP,KAAK4C,cAAcpE,EAAOkB,GAG3BI,cAAkBtB,EAAuBkB,GAAW,GAE1D,MAAM+C,EAAWzC,KAAKsC,UAAU3F,IAAI6B,GAEpC,GAAKiE,EAOL,OAAOA,EAAUR,UALb,IAAKvC,EAAU,MAAM0C,EAAY5D,ICnE7C9C,EAAAU,EAAA2G,EAAA,+BAAAC,IAAAtH,EAAAU,EAAA2G,EAAA,uCAAA5E,IAAAzC,EAAAU,EAAA2G,EAAA,uCAAAxE,IAAA7C,EAAAU,EAAA2G,EAAA,2CAAArE,IAAAhD,EAAAU,EAAA2G,EAAA,4CAAAlE,IAAAnD,EAAAU,EAAA2G,EAAA,+CAAAnE,IAAAlD,EAAAU,EAAA2G,EAAA,0CAAA5D,IAAAzD,EAAAU,EAAA2G,EAAA,2CAAAzD,IAAA5D,EAAAU,EAAA2G,EAAA,8CAAAxD,IAAA7D,EAAAU,EAAA2G,EAAA,6CAAA1D,IAAA3D,EAAAU,EAAA2G,EAAA,8CAAA7D,IAAAxD,EAAAU,EAAA2G,EAAA,6CAAAtD,IAAA/D,EAAAU,EAAA2G,EAAA,kCAAAhD,IAAArE,EAAAU,EAAA2G,EAAA,6BAAA5C,IAAAzE,EAAAU,EAAA2G,EAAA,2BAAApD,IAAAjE,EAAAU,EAAA2G,EAAA,+BAAA1C,IAAA3E,EAAAU,EAAA2G,EAAA,6BAAAzC,IAAA5E,EAAAU,EAAA2G,EAAA,uCAAArC,IAAAhF,EAAAU,EAAA2G,EAAA,2CAAAnC,IAAAlF,EAAAU,EAAA2G,EAAA,uCAAAjC,IAAApF,EAAAU,EAAA2G,EAAA,0CAAAhC,IAAArF,EAAAU,EAAA2G,EAAA,iCAAA9B,IAAAvF,EAAAU,EAAA2G,EAAA,kCAAAlB,IAAAnG,EAAAU,EAAA2G,EAAA,sCAAAhB,IAAArG,EAAAU,EAAA2G,EAAA,kCAAAb,IAAAxG,EAAAU,EAAA2G,EAAA,gCAAAlD,IAAAnE,EAAAU,EAAA2G,EAAA,yCAAAZ,IAAAzG,EAAAU,EAAA2G,EAAA,gCAAAX,IAAA1G,EAAAU,EAAA2G,EAAA,6BAAAV","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export const DESIGN_TYPE            = 'design:type';\nexport const DESIGN_PARAMETER_TYPES = 'design:paramtypes';\n\nexport const TOKEN           = 'ioc:token';\nexport const PARAMETERS      = 'ioc:parameters';\nexport const PROPERTIES      = 'ioc:properties';","import { Constructor } from '../decorators';\nimport { InjectToken } from '../inject-token';\nimport * as ANNOTATION from './metadata-keys';\n\nexport { ANNOTATION };\n\nexport interface ParameterAnnotation<T = any> {\n    token: InjectToken<T> | Constructor<T>;\n    optional: boolean;\n}\n\nexport interface PropertyAnnotation<T = any> {\n    token: InjectToken<T> | Constructor<T>;\n    optional: boolean;\n}\n\nexport const getTokenAnnotation = <T> (target: Constructor<T>): InjectToken<T> => {\n\n    return Reflect.getOwnMetadata(ANNOTATION.TOKEN, target);\n};\n\nexport const setTokenAnnotation = <T> (target: Constructor<T>, token: InjectToken<T>): void => {\n\n    Reflect.defineMetadata(ANNOTATION.TOKEN, token, target);\n};\n\nexport const getParameterAnnotation = (target: Constructor, parameterIndex: number): ParameterAnnotation => {\n\n    ensureParameterAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target)[parameterIndex];\n};\n\nexport const getParameterAnnotations = (target: Constructor): ParameterAnnotation[] => {\n\n    ensureParameterAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target);\n};\n\nexport const ensureParameterAnnotations = (target: Constructor) => {\n\n    if (!Reflect.hasOwnMetadata(ANNOTATION.PARAMETERS, target)) {\n\n        const parameterTypes: Constructor[]               = Reflect.getOwnMetadata(ANNOTATION.DESIGN_PARAMETER_TYPES, target) || [];\n        const parameterAnnotations: ParameterAnnotation[] = parameterTypes.map(type => createParameterAnnotation(type));\n\n        Reflect.defineMetadata(ANNOTATION.PARAMETERS, parameterAnnotations, target);\n    }\n};\n\nexport const getPropertyAnnotation = (target: Constructor, propertyKey: string): PropertyAnnotation => {\n\n    ensurePropertyAnnotation(target, propertyKey);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target)[propertyKey];\n};\n\nexport const getPropertyAnnotations = (target: Constructor): { [key: string]: PropertyAnnotation } => {\n\n    ensurePropertyAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target);\n};\n\nexport const ensurePropertyAnnotations = (target: Constructor) => {\n\n    if (!Reflect.hasOwnMetadata(ANNOTATION.PROPERTIES, target)) {\n\n        Reflect.defineMetadata(ANNOTATION.PROPERTIES, {}, target);\n    }\n};\n\nexport const ensurePropertyAnnotation = (target: Constructor, propertyKey: string) => {\n\n    ensurePropertyAnnotations(target);\n\n    const properties: { [key: string]: PropertyAnnotation } = Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target);\n\n    if (!properties.hasOwnProperty(propertyKey)) {\n\n        properties[propertyKey] = createPropertyAnnotation(Reflect.getOwnMetadata(ANNOTATION.DESIGN_TYPE, target.prototype, propertyKey));\n    }\n};\n\nexport const createParameterAnnotation = <T> (token: InjectToken<T> | Constructor<T>, optional = false): ParameterAnnotation<T> => ({\n    token:    token,\n    optional: optional\n});\n\nexport const createPropertyAnnotation = <T> (token: InjectToken<T> | Constructor<T>, optional = false): PropertyAnnotation<T> => ({\n    token:    token,\n    optional: optional\n});","import { getParameterAnnotation, getPropertyAnnotation } from '../annotations';\nimport { InjectToken } from '../inject-token';\nimport { Constructor } from './index';\n\nexport const inject = <T> (token: InjectToken<T>) => {\n\n    return (target: Object, propertyKey: string | symbol, parameterIndex?: number): void => {\n\n        if (typeof parameterIndex === 'number') {\n\n            // decorator is a parameter decorator\n            const parameterAnnotation = getParameterAnnotation(target as Constructor<any>, parameterIndex);\n\n            parameterAnnotation.token = token;\n\n            // console.log('inject()... ', parameterAnnotation);\n\n        } else {\n\n            // decorator is a property decorator\n            const propertyAnnotation = getPropertyAnnotation(target.constructor as Constructor<any>, propertyKey as string);\n\n            propertyAnnotation.token = token;\n\n            // console.log('inject()... ', propertyAnnotation);\n        }\n    };\n};\n","import { Constructor, isConstructor, isSymbol } from './decorators';\n\nexport class InjectToken<T = any> {\n\n    description: string;\n\n    value: Symbol;\n\n    constructor (value: Constructor<T> | symbol | string) {\n\n        if (isConstructor(value)) {\n\n            this.value       = Symbol.for(value.name);\n            this.description = value.name;\n\n        } else if (isSymbol(value)) {\n\n            this.value       = value;\n            this.description = value.toString();\n\n        } else {\n\n            this.value       = Symbol.for(value);\n            this.description = value;\n        }\n    }\n}","import { InjectToken } from '../inject-token';\nimport { setTokenAnnotation } from '../annotations';\nimport { Constructor } from './index';\n\nexport const injectable = () => {\n\n    return (target: Constructor<object>) => {\n\n        const token = new InjectToken(target);\n\n        setTokenAnnotation(target, token);\n    };\n};\n","import { getParameterAnnotation, getPropertyAnnotation } from '../annotations';\nimport { Constructor } from './index';\n\nexport const optional = () => {\n\n    return (target: Object, propertyKey: string | symbol, parameterIndex?: number): void => {\n\n        if (typeof parameterIndex === 'number') {\n\n            // decorator is a parameter decorator\n            const parameterAnnotation = getParameterAnnotation(target as Constructor<any>, parameterIndex);\n\n            parameterAnnotation.optional = true;\n\n        } else {\n\n            // decorator is a property decorator\n            const propertyAnnotation = getPropertyAnnotation(target.constructor as Constructor<any>, propertyKey as string);\n\n            propertyAnnotation.optional = true;\n        }\n    };\n};","export type Constructor<T = any> = { new (...args: any[]): T; }\n\nexport const isConstructor = <T> (constructorFn: any): constructorFn is Constructor<T> => {\n\n    return constructorFn instanceof Function && constructorFn.prototype && constructorFn.prototype.constructor === constructorFn;\n};\n\nexport const isSymbol = (symbol: any): symbol is Symbol => {\n\n    return typeof symbol === 'symbol';\n};\n\nexport * from './inject';\nexport * from './injectable';\nexport * from './optional';\n","import { Constructor } from '../decorators';\nimport { Factory } from './index';\n\nexport interface ClassFactory<T> extends Factory<T> {\n    (...dependencies: any[]): T;\n}\n\nexport const createClassFactory = <T> (constructorFn: Constructor<T>): ClassFactory<T> => {\n\n    return (...dependencies: any[]) => {\n\n        // console.log(`ClassFactory<${constructorFn.name}>()... [dependencies]: `, dependencies);\n\n        return new constructorFn(...dependencies);\n    };\n};","import { Constructor } from '../decorators';\nimport { Factory } from './index';\n\nexport interface SingletonFactory<T> extends Factory<T> {\n    (...dependencies: any[]): T;\n}\n\nexport const createSingletonFactory = <T> (constructorFn: Constructor<T>): SingletonFactory<T> => {\n\n    let instance: T;\n\n    return (...dependencies: any[]) => {\n\n        if (!instance) instance = new constructorFn(...dependencies);\n\n        return instance;\n    };\n};","import { Factory } from './index';\n\nexport interface ValueFactory<T> extends Factory<T> {\n    (): T;\n}\n\nexport const createValueFactory = <T> (value: T): ValueFactory<T> => {\n\n    return () => value;\n};\n","import { ParameterAnnotation, PropertyAnnotation } from '../annotations';\nimport { Factory } from '../factories';\nimport { Injector } from '../injector';\nimport { Provider } from './index';\n\nexport const PROVIDER_UNREGISTERED = new Error('Provider is not registered with an injector.');\n\nexport class BaseProvider<T> implements Provider<T> {\n\n    public injector: Injector | undefined;\n\n    constructor (public factory: Factory<T>,\n                 public dependencies: ParameterAnnotation[]               = [],\n                 public properties: { [key: string]: PropertyAnnotation } = {}) {}\n\n    provide (): T {\n\n        if (!this.injector) throw PROVIDER_UNREGISTERED;\n\n        // console.group('Provider.provide()');\n\n        // console.log('provider: ', this);\n        // console.log('resolving dependencies: ', this.dependencies);\n\n        const dependencies = this._resolveDependencies();\n\n        // console.log('resolved dependencies: ', dependencies);\n\n        // console.log('resolving properties: ', this.properties);\n\n        const properties = this._resolveProperties();\n\n        // console.log('resolved properties: ', properties);\n\n        // console.groupEnd();\n\n        return this._createValue(dependencies, properties);\n    }\n\n    protected _createValue (dependencies: any[], properties: { [key: string]: any }): T {\n\n        const value = this.factory(...dependencies);\n\n        return (value instanceof Object) ? Object.assign(value, properties) : value;\n    }\n\n    protected _resolveDependencies (): any[] {\n\n        return this.dependencies.map(dependency => this.injector!.resolve(dependency.token, dependency.optional));\n    }\n\n    protected _resolveProperties (): { [key: string]: any } {\n\n        return Object.entries(this.properties).reduce((result, [key, value]) => {\n\n            result[key] = this.injector!.resolve(value.token, value.optional);\n\n            return result;\n\n        }, {} as { [key: string]: any });\n    }\n}\n","import { Constructor } from '../decorators';\nimport { createClassFactory } from '../factories';\nimport { getParameterAnnotations, getPropertyAnnotations, ParameterAnnotation, PropertyAnnotation } from '../annotations';\nimport { BaseProvider } from './index';\n\nexport class ClassProvider<T> extends BaseProvider<T> {\n\n    constructor (constructorFn: Constructor<T>,\n                 dependencies?: ParameterAnnotation[],\n                 properties?: { [key: string]: PropertyAnnotation }) {\n\n        super(\n            createClassFactory(constructorFn),\n            dependencies || getParameterAnnotations(constructorFn),\n            properties || getPropertyAnnotations(constructorFn)\n        );\n    }\n}\n","import { ClassProvider } from './class-provider';\n\nexport class SingletonProvider<T> extends ClassProvider<T> {\n\n    protected _instance: T | undefined;\n\n    provide (): T {\n\n        if (!this._instance) this._instance = super.provide();\n\n        return this._instance;\n    }\n}\n","import { createValueFactory } from '../factories';\nimport { BaseProvider } from './base-provider';\n\nexport class ValueProvider<T> extends BaseProvider<T> {\n\n    constructor (value: any) {\n\n        super(createValueFactory(value));\n    }\n}\n","import { getTokenAnnotation } from './annotations';\nimport { Constructor } from './decorators';\nimport { InjectToken } from './inject-token';\nimport { ClassProvider, Provider } from './providers';\n\nexport const CLASS_NOT_INJECTABLE = (constructorFn: Constructor) => new Error(`Class '${constructorFn.name}' has not been decorated as injectable and cannot be resolved.`);\nexport const NO_PROVIDER          = (token: InjectToken) => new Error(`No provider has been found for the requested token '${token.description}'.`);\n\nexport class Injector {\n\n    private _registry: Map<InjectToken<any>, Provider<any>> = new Map();\n\n    provide<T> (constructorOrToken: Constructor<T> | InjectToken<T>, provider: Provider<T>) {\n\n        const token: InjectToken<T> = constructorOrToken instanceof InjectToken ?\n                                      constructorOrToken :\n                                      getTokenAnnotation(constructorOrToken);\n\n        // class was not decorated with @injectable, throw\n        if (!token) throw CLASS_NOT_INJECTABLE(constructorOrToken as Constructor);\n\n        provider.injector = this;\n\n        this._registry.set(token, provider);\n    }\n\n    resolve<T> (target: Constructor<T> | InjectToken<T>, optional = false): T | undefined {\n\n        let resolved: T | undefined;\n\n        // console.group('Injector.resolve()');\n\n        if (target instanceof InjectToken) {\n\n            // console.log('resolving: ', target.value);\n            resolved = this._resolveToken(target, optional);\n\n        } else {\n\n            // console.log('resolving: ', target.name);\n            resolved = this._resolveConstructor(target, optional);\n        }\n\n        // console.groupEnd();\n\n        return resolved;\n    }\n\n    protected _resolveConstructor<T> (constructorFn: Constructor<T>, optional = false): T | undefined {\n\n        const token: InjectToken<T> = getTokenAnnotation(constructorFn);\n\n        // class was not decorated with @injectable, throw\n        if (!token) throw CLASS_NOT_INJECTABLE(constructorFn);\n\n        // class has no provider yet, we create one\n        if (!this._registry.has(token)) this.provide(token, new ClassProvider(constructorFn));\n\n        return this._resolveToken(token, optional);\n    }\n\n    protected _resolveToken<T> (token: InjectToken<T>, optional = false): T | undefined {\n\n        const provider = this._registry.get(token);\n\n        if (!provider) {\n\n            if (!optional) throw NO_PROVIDER(token);\n\n            return undefined;\n        }\n\n        return provider!.provide();\n    }\n}\n","export * from './annotations';\nexport * from './decorators';\nexport * from './factories';\nexport * from './providers';\nexport * from './inject-token';\nexport * from './injector';\n"],"sourceRoot":""}