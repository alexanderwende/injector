{"version":3,"file":"index.esm.js","sources":["../src/utils/index.ts","../src/annotations/metadata-keys.ts","../src/annotations/index.ts","../src/inject-token.ts","../src/decorators/inject.ts","../src/decorators/injectable.ts","../src/decorators/optional.ts","../src/factories/class-factory.ts","../src/factories/singleton-factory.ts","../src/factories/value-factory.ts","../src/providers/base-provider.ts","../src/providers/class-provider.ts","../src/providers/singleton-provider.ts","../src/providers/value-provider.ts","../src/injector.ts"],"sourcesContent":["export type Constructor<T = any> = { new (...args: any[]): T; }\n\nexport const isConstructor = (constructorFn: any): constructorFn is Constructor => {\n\n    return constructorFn instanceof Function && constructorFn.prototype && constructorFn.prototype.constructor === constructorFn;\n};\n\nexport const isSymbol = (symbol: any): symbol is Symbol => {\n\n    return typeof symbol === 'symbol';\n};\n","/**\n * @internal\n */\nexport const DESIGN_TYPE = 'design:type';\n\n/**\n * @internal\n */\nexport const DESIGN_PARAMETER_TYPES = 'design:paramtypes';\n\n/**\n * @internal\n */\nexport const TOKEN = 'ioc:token';\n\n/**\n * @internal\n */\nexport const PARAMETERS = 'ioc:parameters';\n\n/**\n * @internal\n */\nexport const PROPERTIES = 'ioc:properties';\n","import '@abraham/reflection';\nimport { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\nimport * as ANNOTATION from './metadata-keys';\n\n/**\n * @internal\n */\nexport { ANNOTATION };\n\nexport interface ParameterAnnotation<T = any> {\n    token: InjectToken<T> | Constructor<T>;\n    optional: boolean;\n}\n\nexport interface PropertyAnnotation<T = any> {\n    token: InjectToken<T> | Constructor<T>;\n    optional: boolean;\n}\n\n/**\n * @internal\n */\nexport const getTokenAnnotation = <T> (target: Constructor<T>): InjectToken<T> | undefined => {\n\n    return Reflect.getOwnMetadata(ANNOTATION.TOKEN, target);\n};\n\n/**\n * @internal\n */\nexport const setTokenAnnotation = <T> (target: Constructor<T>, token: InjectToken<T>): void => {\n\n    Reflect.defineMetadata(ANNOTATION.TOKEN, token, target);\n};\n\n/**\n * @internal\n */\nexport const getParameterAnnotation = (target: Constructor, parameterIndex: number): ParameterAnnotation => {\n\n    ensureParameterAnnotations(target);\n\n    return (Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target) as ParameterAnnotation[])[parameterIndex];\n};\n\n/**\n * @internal\n */\nexport const getParameterAnnotations = (target: Constructor): ParameterAnnotation[] => {\n\n    ensureParameterAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PARAMETERS, target) as ParameterAnnotation[];\n};\n\n/**\n * @internal\n */\nexport const ensureParameterAnnotations = (target: Constructor) => {\n\n    if (!Reflect.hasOwnMetadata(ANNOTATION.PARAMETERS, target)) {\n\n        const parameterTypes: Constructor[] = Reflect.getOwnMetadata(ANNOTATION.DESIGN_PARAMETER_TYPES, target) || [];\n        const parameterAnnotations: ParameterAnnotation[] = parameterTypes.map(type => createParameterAnnotation(type));\n\n        Reflect.defineMetadata(ANNOTATION.PARAMETERS, parameterAnnotations, target);\n    }\n};\n\n/**\n * @internal\n */\nexport const getPropertyAnnotation = (target: Constructor, propertyKey: string): PropertyAnnotation => {\n\n    ensurePropertyAnnotation(target, propertyKey);\n\n    return (Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target) as { [key: string]: PropertyAnnotation })[propertyKey];\n};\n\n/**\n * @internal\n */\nexport const getPropertyAnnotations = (target: Constructor): { [key: string]: PropertyAnnotation } => {\n\n    ensurePropertyAnnotations(target);\n\n    return Reflect.getOwnMetadata(ANNOTATION.PROPERTIES, target) as { [key: string]: PropertyAnnotation };\n};\n\n/**\n * @internal\n */\nexport const ensurePropertyAnnotations = (target: Constructor) => {\n\n    if (!Reflect.hasOwnMetadata(ANNOTATION.PROPERTIES, target)) {\n\n        Reflect.defineMetadata(ANNOTATION.PROPERTIES, {}, target);\n    }\n};\n\n/**\n * @internal\n */\nexport const ensurePropertyAnnotation = (target: Constructor, propertyKey: string) => {\n\n    const properties = getPropertyAnnotations(target);\n\n    if (!properties.hasOwnProperty(propertyKey)) {\n\n        const propertyType: InjectToken | Constructor = Reflect.getOwnMetadata(ANNOTATION.DESIGN_TYPE, target.prototype, propertyKey) as InjectToken | Constructor;\n\n        properties[propertyKey] = createPropertyAnnotation(propertyType);\n    }\n};\n\n/**\n * @internal\n */\nexport const createParameterAnnotation = <T> (token: InjectToken<T> | Constructor<T>, optional = false): ParameterAnnotation<T> => ({\n    token: token,\n    optional: optional\n});\n\n/**\n * @internal\n */\nexport const createPropertyAnnotation = <T> (token: InjectToken<T> | Constructor<T>, optional = false): PropertyAnnotation<T> => ({\n    token: token,\n    optional: optional\n});\n","import { Constructor, isConstructor, isSymbol } from './utils';\n\nexport class InjectToken<T = any> {\n\n    description: string;\n\n    value: Symbol;\n\n    constructor (value: Constructor<T> | symbol | string) {\n\n        if (isConstructor(value)) {\n\n            this.value       = Symbol.for(value.name);\n            this.description = value.name;\n\n        } else if (isSymbol(value)) {\n\n            this.value       = value;\n            this.description = value.toString();\n\n        } else {\n\n            this.value       = Symbol.for(value);\n            this.description = value;\n        }\n    }\n}","import { getParameterAnnotation, getPropertyAnnotation, getTokenAnnotation } from '../annotations';\nimport { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\n\n/**\n * @internal\n */\nexport const CLASS_NOT_INJECTABLE = (constructorFn: Constructor) => new Error(`Class '${ constructorFn.name }' has not been decorated as injectable and cannot be injected.`);\n\nexport const inject = <T> (constructorOrToken?: Constructor<T> | InjectToken<T>) => {\n\n    return (target: Object, propertyKey: string | symbol, parameterIndex?: number): void => {\n\n        const isParameterDecorator = typeof parameterIndex === 'number';\n\n        const token: Constructor<T> | InjectToken<T> | undefined = (constructorOrToken instanceof InjectToken) ?\n                                                                   constructorOrToken :\n                                                                   (constructorOrToken instanceof Function) ?\n                                                                   getTokenAnnotation(constructorOrToken) :\n                                                                   (isParameterDecorator) ?\n                                                                   getParameterAnnotation(target as Constructor, parameterIndex!).token :\n                                                                   getPropertyAnnotation(target.constructor as Constructor, propertyKey as string).token;\n\n        // token can only be undefined, when injecting a class type\n        if (!token) {\n\n            throw CLASS_NOT_INJECTABLE(constructorOrToken as Constructor);\n        }\n\n        if (isParameterDecorator) {\n\n            // decorator is a parameter decorator\n            const parameterAnnotation = getParameterAnnotation(target as Constructor, parameterIndex!);\n\n            parameterAnnotation.token = token;\n\n            // console.log('inject()... ', parameterAnnotation);\n\n        } else {\n\n            // decorator is a property decorator\n            const propertyAnnotation = getPropertyAnnotation(target.constructor as Constructor, propertyKey as string);\n\n            propertyAnnotation.token = token;\n\n            // console.log('inject()... ', propertyAnnotation);\n        }\n    };\n};\n","import { setTokenAnnotation } from '../annotations';\nimport { InjectToken } from '../inject-token';\nimport { Constructor } from '../utils';\n\nexport const injectable = () => {\n\n    return (target: Constructor<object>) => {\n\n        const token = new InjectToken(target);\n\n        setTokenAnnotation(target, token);\n    };\n};\n","import { getParameterAnnotation, getPropertyAnnotation } from '../annotations';\nimport { Constructor } from '../utils';\n\nexport const optional = () => {\n\n    return (target: Object, propertyKey: string | symbol, parameterIndex?: number): void => {\n\n        if (typeof parameterIndex === 'number') {\n\n            // decorator is a parameter decorator\n            const parameterAnnotation = getParameterAnnotation(target as Constructor<any>, parameterIndex);\n\n            parameterAnnotation.optional = true;\n\n        } else {\n\n            // decorator is a property decorator\n            const propertyAnnotation = getPropertyAnnotation(target.constructor as Constructor<any>, propertyKey as string);\n\n            propertyAnnotation.optional = true;\n        }\n    };\n};\n","import { Constructor } from '../utils';\nimport { Factory } from './factory';\n\nexport interface ClassFactory<T> extends Factory<T> {\n    (...dependencies: any[]): T;\n}\n\nexport const createClassFactory = <T> (constructorFn: Constructor<T>): ClassFactory<T> => {\n\n    return (...dependencies: any[]) => {\n\n        return Reflect.construct(constructorFn, dependencies);\n    };\n};\n","import { Constructor } from '../utils';\nimport { Factory } from './factory';\n\nexport interface SingletonFactory<T> extends Factory<T> {\n    (...dependencies: any[]): T;\n}\n\nexport const createSingletonFactory = <T> (constructorFn: Constructor<T>): SingletonFactory<T> => {\n\n    let instance: T;\n\n    return (...dependencies: any[]) => {\n\n        if (!instance) instance = Reflect.construct(constructorFn, dependencies);\n\n        return instance;\n    };\n};\n","import { Factory } from './factory';\n\nexport interface ValueFactory<T> extends Factory<T> {\n    (): T;\n}\n\nexport const createValueFactory = <T> (value: T): ValueFactory<T> => {\n\n    return () => value;\n};\n","import { ParameterAnnotation, PropertyAnnotation } from '../annotations';\nimport { Factory } from '../factories';\nimport { Injector } from '../injector';\nimport { Provider } from './provider';\n\n/**\n * @internal\n */\nexport const PROVIDER_UNREGISTERED = new Error('Provider is not registered with an injector.');\n\nexport class BaseProvider<T> implements Provider<T> {\n\n    public injector: Injector | undefined;\n\n    constructor (public factory: Factory<T>,\n                 public dependencies: ParameterAnnotation[]               = [],\n                 public properties: { [key: string]: PropertyAnnotation } = {}) {}\n\n    provide (injector?: Injector): T {\n\n        if (!injector) injector = this.injector;\n\n        if (!injector) throw PROVIDER_UNREGISTERED;\n\n        // console.group('Provider.provide()');\n\n        // console.log('provider: ', this);\n        // console.log('resolving dependencies: ', this.dependencies);\n\n        const dependencies = this.resolveDependencies(injector);\n\n        // console.log('resolved dependencies: ', dependencies);\n\n        // console.log('resolving properties: ', this.properties);\n\n        const properties = this.resolveProperties(injector);\n\n        // console.log('resolved properties: ', properties);\n\n        // console.groupEnd();\n\n        return this.createValue(dependencies, properties);\n    }\n\n    resolveDependencies (injector: Injector): any[] {\n\n        return this.dependencies.map(dependency => injector.resolve(dependency.token, dependency.optional));\n    }\n\n    resolveProperties (injector: Injector): { [key: string]: any } {\n\n        return Object.entries(this.properties).reduce((result, [key, value]) => {\n\n            result[key] = injector.resolve(value.token, value.optional);\n\n            return result;\n\n        }, {} as { [key: string]: any });\n    }\n\n    createValue (dependencies: any[] = [], properties: { [key: string]: any } = {}): T {\n\n        const value = this.factory(...dependencies);\n\n        return (value instanceof Object) ? Object.assign(value, properties) : value;\n    }\n}\n","import { getParameterAnnotations, getPropertyAnnotations, ParameterAnnotation, PropertyAnnotation } from '../annotations';\nimport { createClassFactory } from '../factories';\nimport { Constructor } from '../utils';\nimport { BaseProvider } from './base-provider';\n\nexport class ClassProvider<T> extends BaseProvider<T> {\n\n    constructor (constructorFn: Constructor<T>,\n                 dependencies?: ParameterAnnotation[],\n                 properties?: { [key: string]: PropertyAnnotation }) {\n\n        super(\n            createClassFactory(constructorFn),\n            dependencies || getParameterAnnotations(constructorFn),\n            properties || getPropertyAnnotations(constructorFn)\n        );\n    }\n}\n","import { ClassProvider } from './class-provider';\n\nexport class SingletonProvider<T> extends ClassProvider<T> {\n\n    protected _instance: T | undefined;\n\n    provide (): T {\n\n        if (!this._instance) this._instance = super.provide();\n\n        return this._instance;\n    }\n}\n","import { createValueFactory } from '../factories';\nimport { BaseProvider } from './base-provider';\n\nexport class ValueProvider<T> extends BaseProvider<T> {\n\n    constructor (value: any) {\n\n        super(createValueFactory(value));\n    }\n}\n","import { getTokenAnnotation } from './annotations';\nimport { InjectToken } from './inject-token';\nimport { ClassProvider, Provider } from './providers';\nimport { Constructor } from './utils';\n\n/**\n * @internal\n */\nexport const CLASS_NOT_PROVIDABLE = (constructorFn: Constructor) => new Error(`Class '${ constructorFn.name }' has not been decorated as injectable and cannot be resolved.`);\n\n/**\n * @internal\n */\nexport const NO_PROVIDER          = (token: InjectToken) => new Error(`No provider has been found for the requested token '${ token.description }'.`);\n\nexport class Injector {\n\n    private _registry: Map<InjectToken<any>, Provider<any>> = new Map();\n\n    private _parent: Injector | null = null;\n\n    /**\n     * Creates an injector instance.\n     *\n     * @remarks\n     * A child injector can be created by passing the parent injector as a constructor argument.\n     * ```typescript\n     * const rootInjector = new Injector();\n     * const childInjector = new Injector(rootInjector);\n     * ```\n     *\n     * @param parent - A parent injector\n     *\n     * @public\n     */\n    constructor (parent?: Injector) {\n\n        if (parent) this._parent = parent;\n    }\n\n    /**\n     * Provide a provider for a dependency to the injector\n     *\n     * @param constructorOrToken - A class constructor or {@link InjectToken} to provide\n     * @param provider - A {@link Provider} which will be used to resolve the class or token\n     *\n     * @public\n     */\n    provide<T> (constructorOrToken: Constructor<T> | InjectToken<T>, provider: Provider<T>) {\n\n        const token: InjectToken<T> | undefined = constructorOrToken instanceof InjectToken ?\n                                                  constructorOrToken :\n                                                  getTokenAnnotation(constructorOrToken);\n\n        // class was not decorated with @injectable, throw\n        if (!token) throw CLASS_NOT_PROVIDABLE(constructorOrToken as Constructor);\n\n        provider.injector = this;\n\n        this._registry.set(token, provider);\n    }\n\n    /**\n     * Resolve a dependency\n     *\n     * @param target - A class constructor or {@link InjectToken} to resolve\n     * @param optional - Should the dependency be optional. If `true` the injector will not throw an error if it cannot resolve the dependency and returns `undefined`. If `false` the injector will throw an error if the dependency cannot be resolved.\n     *\n     * @public\n     */\n    resolve<T> (target: Constructor<T> | InjectToken<T>, optional = false): T | undefined {\n\n        let resolved: T | undefined;\n\n        // console.group('Injector.resolve()');\n\n        if (target instanceof InjectToken) {\n\n            // console.log('resolving: ', target.value);\n            resolved = this._resolveToken(target, optional);\n\n        } else {\n\n            // console.log('resolving: ', target.name);\n            resolved = this._resolveConstructor(target, optional);\n        }\n\n        // console.groupEnd();\n\n        return resolved;\n    }\n\n    /**\n     * @internal\n     */\n    protected _resolveConstructor<T> (constructorFn: Constructor<T>, optional = false): T | undefined {\n\n        const token: InjectToken<T> | undefined = getTokenAnnotation(constructorFn);\n\n        // class was not decorated with @injectable, throw\n        if (!token) throw CLASS_NOT_PROVIDABLE(constructorFn);\n\n        // class has no provider yet, we create one\n        if (!this._getProvider(token)) {\n\n            this.provide(token, new ClassProvider(constructorFn));\n        }\n\n        return this._resolveToken(token, optional);\n    }\n\n    /**\n     * @internal\n     */\n    protected _resolveToken<T> (token: InjectToken<T>, optional = false): T | undefined {\n\n        const provider = this._getProvider(token);\n\n        if (!provider) {\n\n            if (!optional) throw NO_PROVIDER(token);\n\n            return undefined;\n        }\n\n        return provider!.provide(this);\n    }\n\n    /**\n     * @internal\n     */\n    protected _getProvider<T> (token: InjectToken<T>): Provider<T> | undefined {\n\n        if (this._registry.has(token)) {\n\n            return this._registry.get(token);\n\n        } else if (this._parent) {\n\n            return this._parent._getProvider(token);\n        }\n    }\n}\n"],"names":["isConstructor","constructorFn","Function","prototype","constructor","isSymbol","symbol","PARAMETERS","PROPERTIES","getTokenAnnotation","target","Reflect","getOwnMetadata","setTokenAnnotation","token","defineMetadata","getParameterAnnotation","parameterIndex","ensureParameterAnnotations","ANNOTATION.PARAMETERS","getParameterAnnotations","hasOwnMetadata","parameterAnnotations","map","type","createParameterAnnotation","getPropertyAnnotation","propertyKey","ensurePropertyAnnotation","ANNOTATION.PROPERTIES","getPropertyAnnotations","ensurePropertyAnnotations","properties","hasOwnProperty","propertyType","createPropertyAnnotation","optional","InjectToken","[object Object]","value","this","Symbol","for","name","description","toString","CLASS_NOT_INJECTABLE","Error","inject","constructorOrToken","isParameterDecorator","injectable","createClassFactory","dependencies","construct","createSingletonFactory","instance","createValueFactory","PROVIDER_UNREGISTERED","BaseProvider","factory","injector","resolveDependencies","resolveProperties","createValue","dependency","resolve","Object","entries","reduce","result","key","assign","ClassProvider","super","SingletonProvider","_instance","provide","ValueProvider","CLASS_NOT_PROVIDABLE","NO_PROVIDER","Injector","parent","Map","_parent","provider","_registry","set","resolved","_resolveToken","_resolveConstructor","_getProvider","has","get"],"mappings":"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"}